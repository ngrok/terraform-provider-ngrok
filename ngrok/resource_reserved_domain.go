// Code generated by apic. DO NOT EDIT.

package ngrok

import (
	"context"
	"net/http"

	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	restapi "github.com/ngrok/terraform-provider-ngrok/restapi"
)

func resourceReservedDomains() *schema.Resource {
	return &schema.Resource{
		Create: resourceReservedDomainsCreate,
		Read:   resourceReservedDomainsGet,
		Update: resourceReservedDomainsUpdate,
		Delete: resourceReservedDomainsDelete,

		Schema: map[string]*schema.Schema{
			"certificate": {
				Type:        schema.TypeList,
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				Description: "object referencing the TLS certificate used for connections to this domain. This can be either a user-uploaded certificate, the most recently issued automatic one, or null otherwise.",
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ngrok_id": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    false,
							Description: "a resource identifier",
						},
						"uri": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    true,
							Description: "a uri for locating a resource",
						},
					},
				},
			},
			"certificate_id": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    false,
				Description: "ID of a user-uploaded TLS certificate to use for connections to targeting this domain. Optional, mutually exclusive with `certificate_management_policy`.",
			},
			"certificate_management_policy": {
				Type:        schema.TypeList,
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    false,
				Description: "configuration for automatic management of TLS certificates for this domain, or null if automatic management is disabled",
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"authority": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    true,
							Description: "certificate authority to request certificates from. The only supported value is letsencrypt.",
						},
						"private_key_type": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    true,
							Description: "type of private key to use when requesting certificates. Defaults to rsa, can be either rsa or ecdsa.",
						},
					},
				},
			},
			"certificate_management_status": {
				Type:        schema.TypeList,
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				Description: "status of the automatic certificate management for this domain, or null if automatic management is disabled",
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"renews_at": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    true,
							Description: "timestamp when the next renewal will be requested, RFC 3339 format",
						},
						"provisioning_job": {
							Type:        schema.TypeList,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    true,
							Description: "status of the certificate provisioning job, or null if the certificiate isn't being provisioned or renewed",
							MaxItems:    1,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"error_code": {
										Type:        schema.TypeString,
										Required:    false,
										Computed:    true,
										Optional:    true,
										Sensitive:   false,
										ForceNew:    true,
										Description: "if present, an error code indicating why provisioning is failing. It may be either a temporary condition (INTERNAL_ERROR), or a permanent one the user must correct (DNS_ERROR).",
									},
									"msg": {
										Type:        schema.TypeString,
										Required:    false,
										Computed:    true,
										Optional:    true,
										Sensitive:   false,
										ForceNew:    true,
										Description: "a message describing the current status or error",
									},
									"started_at": {
										Type:        schema.TypeString,
										Required:    false,
										Computed:    true,
										Optional:    true,
										Sensitive:   false,
										ForceNew:    true,
										Description: "timestamp when the provisioning job started, RFC 3339 format",
									},
									"retries_at": {
										Type:        schema.TypeString,
										Required:    false,
										Computed:    true,
										Optional:    true,
										Sensitive:   false,
										ForceNew:    true,
										Description: "timestamp when the provisioning job will be retried",
									},
									"ns_targets": {
										Type:        schema.TypeList,
										Required:    false,
										Computed:    true,
										Optional:    true,
										Sensitive:   false,
										ForceNew:    true,
										Description: "if present, indicates the dns nameservers that the user must configure to complete the provisioning process of a wildcard certificate",
										MaxItems:    1,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"zone": {
													Type:        schema.TypeString,
													Required:    false,
													Computed:    true,
													Optional:    true,
													Sensitive:   false,
													ForceNew:    true,
													Description: "the zone that the nameservers need to be applied to",
												},
												"nameservers": {
													Type:        schema.TypeList,
													Required:    false,
													Computed:    true,
													Optional:    true,
													Sensitive:   false,
													ForceNew:    true,
													Description: "the nameservers the user must add",
													Elem:        &schema.Schema{Type: schema.TypeString},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"cname_target": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				Description: "DNS CNAME target for a custom hostname, or null if the reserved domain is a subdomain of *.ngrok.io",
			},
			"created_at": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				Description: "timestamp when the reserved domain was created, RFC 3339 format",
			},
			"description": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    false,
				Description: "human-readable description of what this reserved domain will be used for",
			},
			"domain": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    true,
				Optional:    false,
				Sensitive:   false,
				ForceNew:    true,
				Description: "hostname of the reserved domain",
			},
			"http_endpoint_configuration": {
				Type:        schema.TypeList,
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				Description: "object referencing the endpoint configuration applied to http traffic on this domain",
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ngrok_id": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    false,
							Description: "a resource identifier",
						},
						"uri": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    true,
							Description: "a uri for locating a resource",
						},
					},
				},
			},
			"http_endpoint_configuration_id": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    false,
				Description: "ID of an endpoint configuration of type http that will be used to handle inbound http traffic to this domain",
			},
			"https_endpoint_configuration": {
				Type:        schema.TypeList,
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				Description: "object referencing the endpoint configuration applied to https traffic on this domain",
				MaxItems:    1,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"ngrok_id": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    false,
							Description: "a resource identifier",
						},
						"uri": {
							Type:        schema.TypeString,
							Required:    false,
							Computed:    true,
							Optional:    true,
							Sensitive:   false,
							ForceNew:    true,
							Description: "a uri for locating a resource",
						},
					},
				},
			},
			"https_endpoint_configuration_id": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    false,
				Description: "ID of an endpoint configuration of type https that will be used to handle inbound https traffic to this domain",
			},
			"metadata": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    false,
				Description: "arbitrary user-defined machine-readable data of this reserved domain. Optional, max 4096 bytes.",
			},
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Computed:    false,
				Optional:    false,
				Sensitive:   false,
				ForceNew:    true,
				Description: "the domain name to reserve. It may be a full domain name like app.example.com. If the name does not contain a '.' it will reserve that subdomain on ngrok.io.",
			},
			"ngrok_id": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    false,
				Description: "unique reserved domain resource identifier",
			},
			"region": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				Description: "reserve the domain in this geographic ngrok datacenter. Optional, default is us. (au, eu, ap, us, jp, in, sa)",
			},
			"uri": {
				Type:        schema.TypeString,
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ForceNew:    true,
				Description: "URI of the reserved domain API resource",
			},
		},
	}
}

func resourceReservedDomainsCreate(d *schema.ResourceData, m interface{}) (err error) {
	b := m.(*base)

	var arg restapi.ReservedDomainCreate
	if v, ok := d.GetOk("name"); ok {
		arg.Name = *expandString(v)
	}
	if v, ok := d.GetOk("region"); ok {
		arg.Region = *expandString(v)
	}
	if v, ok := d.GetOk("description"); ok {
		arg.Description = *expandString(v)
	}
	if v, ok := d.GetOk("metadata"); ok {
		arg.Metadata = *expandString(v)
	}
	if v, ok := d.GetOk("http_endpoint_configuration_id"); ok {
		arg.HTTPEndpointConfigurationID = *expandString(v)
	}
	if v, ok := d.GetOk("https_endpoint_configuration_id"); ok {
		arg.HTTPSEndpointConfigurationID = *expandString(v)
	}
	if v, ok := d.GetOk("certificate_id"); ok {
		arg.CertificateID = expandString(v)
	}
	if v, ok := d.GetOk("certificate_management_policy"); ok {
		arg.CertificateManagementPolicy = expandReservedDomainCertPolicy(v)
	}

	res, _, err := b.client.ReservedDomainsCreate(context.Background(), &arg)
	if err == nil {
		d.SetId(res.ID)
	}
	return resourceReservedDomainsGet(d, m)
}

func resourceReservedDomainsGet(d *schema.ResourceData, m interface{}) (err error) {
	b := m.(*base)

	res, resp, err := b.client.ReservedDomainsGet(context.Background(), &restapi.Item{
		ID: d.Id(),
	})
	return resourceReservedDomainsGetDecode(d, res, resp, err)
}

func resourceReservedDomainsGetDecode(d *schema.ResourceData, res *restapi.ReservedDomain, resp *http.Response, err error) error {
	switch {
	case resp != nil && resp.StatusCode == 404:
		d.SetId("")
	case err != nil:
		return err
	default:
		d.Set("certificate", flattenRef(res.Certificate))
		if res.Certificate != nil {
			d.Set("certificate_id", res.Certificate.ID)
		}
		d.Set("certificate_management_policy", flattenReservedDomainCertPolicy(res.CertificateManagementPolicy))
		d.Set("certificate_management_status", flattenReservedDomainCertStatus(res.CertificateManagementStatus))
		d.Set("cname_target", res.CNAMETarget)
		d.Set("created_at", res.CreatedAt)
		d.Set("description", res.Description)
		d.Set("domain", res.Domain)
		d.Set("http_endpoint_configuration", flattenRef(res.HTTPEndpointConfiguration))
		if res.HTTPEndpointConfiguration != nil {
			d.Set("http_endpoint_configuration_id", res.HTTPEndpointConfiguration.ID)
		}
		d.Set("https_endpoint_configuration", flattenRef(res.HTTPSEndpointConfiguration))
		if res.HTTPSEndpointConfiguration != nil {
			d.Set("https_endpoint_configuration_id", res.HTTPSEndpointConfiguration.ID)
		}
		d.Set("metadata", res.Metadata)
		d.Set("ngrok_id", res.ID)
		d.Set("region", res.Region)
		d.Set("uri", res.URI)
	}

	return nil
}

func resourceReservedDomainsUpdate(d *schema.ResourceData, m interface{}) (err error) {
	b := m.(*base)

	var arg restapi.ReservedDomainUpdate
	arg.ID = d.Id()
	if v, ok := d.GetOk("ngrok_id"); ok {
		arg.ID = *expandString(v)
	}
	if v, ok := d.GetOk("description"); ok {
		arg.Description = expandString(v)
	}
	if v, ok := d.GetOk("metadata"); ok {
		arg.Metadata = expandString(v)
	}
	if v, ok := d.GetOk("http_endpoint_configuration_id"); ok {
		arg.HTTPEndpointConfigurationID = expandString(v)
	}
	if v, ok := d.GetOk("https_endpoint_configuration_id"); ok {
		arg.HTTPSEndpointConfigurationID = expandString(v)
	}
	if v, ok := d.GetOk("certificate_id"); ok {
		arg.CertificateID = expandString(v)
	}
	if v, ok := d.GetOk("certificate_management_policy"); ok {
		arg.CertificateManagementPolicy = expandReservedDomainCertPolicy(v)
	}

	res, _, err := b.client.ReservedDomainsUpdate(context.Background(), &arg)
	if err != nil {
		return err
	}
	d.SetId(res.ID)

	return resourceReservedDomainsGet(d, m)
}

func resourceReservedDomainsDelete(d *schema.ResourceData, m interface{}) (err error) {
	b := m.(*base)
	_, _, err = b.client.ReservedDomainsDelete(context.Background(), &restapi.Item{ID: d.Id()})
	return err
}
