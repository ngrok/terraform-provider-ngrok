// Code generated by apic. DO NOT EDIT.

package ngrok

import (
	restapi "github.com/ngrok/terraform-provider-ngrok/restapi"
)

func flattenEmpty(obj *restapi.Empty) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})

	return []interface{}{m}
}

func flattenEmptySlice(objs *[]restapi.Empty) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEmpty(&v))
	}
	return sl
}

func expandEmpty(in interface{}) *restapi.Empty {
	if in == nil {
		return nil
	}

	var obj restapi.Empty
	return &obj
}

func expandEmptySlice(in interface{}) *[]restapi.Empty {
	var out []restapi.Empty
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEmpty(v))
	}
	return &out
}

func flattenItem(obj *restapi.Item) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID

	return []interface{}{m}
}

func flattenItemSlice(objs *[]restapi.Item) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenItem(&v))
	}
	return sl
}

func expandItem(in interface{}) *restapi.Item {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Item
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	return &obj
}

func expandItemSlice(in interface{}) *[]restapi.Item {
	var out []restapi.Item
	for _, v := range in.([]interface{}) {
		out = append(out, *expandItem(v))
	}
	return &out
}

func flattenPage(obj *restapi.Page) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["before_id"] = *obj.BeforeID
	m["limit"] = *obj.Limit

	return []interface{}{m}
}

func flattenPageSlice(objs *[]restapi.Page) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenPage(&v))
	}
	return sl
}

func expandPage(in interface{}) *restapi.Page {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Page
	if v, ok := m["before_id"]; ok {
		obj.BeforeID = expandString(v)
	}
	if v, ok := m["limit"]; ok {
		obj.Limit = expandString(v)
	}
	return &obj
}

func expandPageSlice(in interface{}) *[]restapi.Page {
	var out []restapi.Page
	for _, v := range in.([]interface{}) {
		out = append(out, *expandPage(v))
	}
	return &out
}

func flattenError(obj *restapi.Error) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["error_code"] = obj.ErrorCode
	m["status_code"] = obj.StatusCode
	m["msg"] = obj.Msg
	m["details"] = obj.Details

	return []interface{}{m}
}

func flattenErrorSlice(objs *[]restapi.Error) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenError(&v))
	}
	return sl
}

func expandError(in interface{}) *restapi.Error {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Error
	if v, ok := m["error_code"]; ok {
		obj.ErrorCode = *expandString(v)
	}
	if v, ok := m["status_code"]; ok {
		obj.StatusCode = *expandInt32(v)
	}
	if v, ok := m["msg"]; ok {
		obj.Msg = *expandString(v)
	}
	if v, ok := m["details"]; ok {
		obj.Details = *expandStringMap(v)
	}
	return &obj
}

func expandErrorSlice(in interface{}) *[]restapi.Error {
	var out []restapi.Error
	for _, v := range in.([]interface{}) {
		out = append(out, *expandError(v))
	}
	return &out
}

func flattenRef(obj *restapi.Ref) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI

	return []interface{}{m}
}

func flattenRefSlice(objs *[]restapi.Ref) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenRef(&v))
	}
	return sl
}

func expandRef(in interface{}) *restapi.Ref {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Ref
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	return &obj
}

func expandRefSlice(in interface{}) *[]restapi.Ref {
	var out []restapi.Ref
	for _, v := range in.([]interface{}) {
		out = append(out, *expandRef(v))
	}
	return &out
}

func flattenAbuseReport(obj *restapi.AbuseReport) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["urls"] = obj.URLs
	m["metadata"] = obj.Metadata
	m["status"] = obj.Status
	m["hostnames"] = flattenAbuseReportHostnameSlice(&obj.Hostnames)

	return []interface{}{m}
}

func flattenAbuseReportSlice(objs *[]restapi.AbuseReport) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAbuseReport(&v))
	}
	return sl
}

func expandAbuseReport(in interface{}) *restapi.AbuseReport {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.AbuseReport
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["urls"]; ok {
		obj.URLs = *expandStringSlice(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["status"]; ok {
		obj.Status = *expandString(v)
	}
	if v, ok := m["hostnames"]; ok {
		obj.Hostnames = *expandAbuseReportHostnameSlice(v)
	}
	return &obj
}

func expandAbuseReportSlice(in interface{}) *[]restapi.AbuseReport {
	var out []restapi.AbuseReport
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAbuseReport(v))
	}
	return &out
}

func flattenAbuseReportHostname(obj *restapi.AbuseReportHostname) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["hostname"] = obj.Hostname
	m["status"] = obj.Status

	return []interface{}{m}
}

func flattenAbuseReportHostnameSlice(objs *[]restapi.AbuseReportHostname) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAbuseReportHostname(&v))
	}
	return sl
}

func expandAbuseReportHostname(in interface{}) *restapi.AbuseReportHostname {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.AbuseReportHostname
	if v, ok := m["hostname"]; ok {
		obj.Hostname = *expandString(v)
	}
	if v, ok := m["status"]; ok {
		obj.Status = *expandString(v)
	}
	return &obj
}

func expandAbuseReportHostnameSlice(in interface{}) *[]restapi.AbuseReportHostname {
	var out []restapi.AbuseReportHostname
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAbuseReportHostname(v))
	}
	return &out
}

func flattenAbuseReportCreate(obj *restapi.AbuseReportCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["urls"] = obj.URLs
	m["metadata"] = obj.Metadata

	return []interface{}{m}
}

func flattenAbuseReportCreateSlice(objs *[]restapi.AbuseReportCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAbuseReportCreate(&v))
	}
	return sl
}

func expandAbuseReportCreate(in interface{}) *restapi.AbuseReportCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.AbuseReportCreate
	if v, ok := m["urls"]; ok {
		obj.URLs = *expandStringSlice(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	return &obj
}

func expandAbuseReportCreateSlice(in interface{}) *[]restapi.AbuseReportCreate {
	var out []restapi.AbuseReportCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAbuseReportCreate(v))
	}
	return &out
}

func flattenAPIKeyCreate(obj *restapi.APIKeyCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata

	return []interface{}{m}
}

func flattenAPIKeyCreateSlice(objs *[]restapi.APIKeyCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAPIKeyCreate(&v))
	}
	return sl
}

func expandAPIKeyCreate(in interface{}) *restapi.APIKeyCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.APIKeyCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	return &obj
}

func expandAPIKeyCreateSlice(in interface{}) *[]restapi.APIKeyCreate {
	var out []restapi.APIKeyCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAPIKeyCreate(v))
	}
	return &out
}

func flattenAPIKeyUpdate(obj *restapi.APIKeyUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata

	return []interface{}{m}
}

func flattenAPIKeyUpdateSlice(objs *[]restapi.APIKeyUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAPIKeyUpdate(&v))
	}
	return sl
}

func expandAPIKeyUpdate(in interface{}) *restapi.APIKeyUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.APIKeyUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	return &obj
}

func expandAPIKeyUpdateSlice(in interface{}) *[]restapi.APIKeyUpdate {
	var out []restapi.APIKeyUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAPIKeyUpdate(v))
	}
	return &out
}

func flattenAPIKey(obj *restapi.APIKey) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["created_at"] = obj.CreatedAt
	m["token"] = *obj.Token

	return []interface{}{m}
}

func flattenAPIKeySlice(objs *[]restapi.APIKey) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAPIKey(&v))
	}
	return sl
}

func expandAPIKey(in interface{}) *restapi.APIKey {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.APIKey
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["token"]; ok {
		obj.Token = expandString(v)
	}
	return &obj
}

func expandAPIKeySlice(in interface{}) *[]restapi.APIKey {
	var out []restapi.APIKey
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAPIKey(v))
	}
	return &out
}

func flattenAPIKeyList(obj *restapi.APIKeyList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["keys"] = flattenAPIKeySlice(&obj.Keys)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenAPIKeyListSlice(objs *[]restapi.APIKeyList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAPIKeyList(&v))
	}
	return sl
}

func expandAPIKeyList(in interface{}) *restapi.APIKeyList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.APIKeyList
	if v, ok := m["keys"]; ok {
		obj.Keys = *expandAPIKeySlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandAPIKeyListSlice(in interface{}) *[]restapi.APIKeyList {
	var out []restapi.APIKeyList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAPIKeyList(v))
	}
	return &out
}

func flattenCertificateAuthorityCreate(obj *restapi.CertificateAuthorityCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["ca_pem"] = obj.CAPEM

	return []interface{}{m}
}

func flattenCertificateAuthorityCreateSlice(objs *[]restapi.CertificateAuthorityCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCertificateAuthorityCreate(&v))
	}
	return sl
}

func expandCertificateAuthorityCreate(in interface{}) *restapi.CertificateAuthorityCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.CertificateAuthorityCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["ca_pem"]; ok {
		obj.CAPEM = *expandString(v)
	}
	return &obj
}

func expandCertificateAuthorityCreateSlice(in interface{}) *[]restapi.CertificateAuthorityCreate {
	var out []restapi.CertificateAuthorityCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCertificateAuthorityCreate(v))
	}
	return &out
}

func flattenCertificateAuthorityUpdate(obj *restapi.CertificateAuthorityUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata

	return []interface{}{m}
}

func flattenCertificateAuthorityUpdateSlice(objs *[]restapi.CertificateAuthorityUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCertificateAuthorityUpdate(&v))
	}
	return sl
}

func expandCertificateAuthorityUpdate(in interface{}) *restapi.CertificateAuthorityUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.CertificateAuthorityUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	return &obj
}

func expandCertificateAuthorityUpdateSlice(in interface{}) *[]restapi.CertificateAuthorityUpdate {
	var out []restapi.CertificateAuthorityUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCertificateAuthorityUpdate(v))
	}
	return &out
}

func flattenCertificateAuthority(obj *restapi.CertificateAuthority) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["ca_pem"] = obj.CAPEM
	m["subject_common_name"] = obj.SubjectCommonName
	m["not_before"] = obj.NotBefore
	m["not_after"] = obj.NotAfter
	m["key_usages"] = obj.KeyUsages
	m["extended_key_usages"] = obj.ExtendedKeyUsages

	return []interface{}{m}
}

func flattenCertificateAuthoritySlice(objs *[]restapi.CertificateAuthority) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCertificateAuthority(&v))
	}
	return sl
}

func expandCertificateAuthority(in interface{}) *restapi.CertificateAuthority {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.CertificateAuthority
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["ca_pem"]; ok {
		obj.CAPEM = *expandString(v)
	}
	if v, ok := m["subject_common_name"]; ok {
		obj.SubjectCommonName = *expandString(v)
	}
	if v, ok := m["not_before"]; ok {
		obj.NotBefore = *expandString(v)
	}
	if v, ok := m["not_after"]; ok {
		obj.NotAfter = *expandString(v)
	}
	if v, ok := m["key_usages"]; ok {
		obj.KeyUsages = *expandStringSlice(v)
	}
	if v, ok := m["extended_key_usages"]; ok {
		obj.ExtendedKeyUsages = *expandStringSlice(v)
	}
	return &obj
}

func expandCertificateAuthoritySlice(in interface{}) *[]restapi.CertificateAuthority {
	var out []restapi.CertificateAuthority
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCertificateAuthority(v))
	}
	return &out
}

func flattenCertificateAuthorityList(obj *restapi.CertificateAuthorityList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["certificate_authorities"] = flattenCertificateAuthoritySlice(&obj.CertificateAuthorities)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenCertificateAuthorityListSlice(objs *[]restapi.CertificateAuthorityList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCertificateAuthorityList(&v))
	}
	return sl
}

func expandCertificateAuthorityList(in interface{}) *restapi.CertificateAuthorityList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.CertificateAuthorityList
	if v, ok := m["certificate_authorities"]; ok {
		obj.CertificateAuthorities = *expandCertificateAuthoritySlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandCertificateAuthorityListSlice(in interface{}) *[]restapi.CertificateAuthorityList {
	var out []restapi.CertificateAuthorityList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCertificateAuthorityList(v))
	}
	return &out
}

func flattenCredentialCreate(obj *restapi.CredentialCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["acl"] = obj.ACL

	return []interface{}{m}
}

func flattenCredentialCreateSlice(objs *[]restapi.CredentialCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCredentialCreate(&v))
	}
	return sl
}

func expandCredentialCreate(in interface{}) *restapi.CredentialCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.CredentialCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["acl"]; ok {
		obj.ACL = *expandStringSlice(v)
	}
	return &obj
}

func expandCredentialCreateSlice(in interface{}) *[]restapi.CredentialCreate {
	var out []restapi.CredentialCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCredentialCreate(v))
	}
	return &out
}

func flattenCredentialUpdate(obj *restapi.CredentialUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata
	m["acl"] = *obj.ACL

	return []interface{}{m}
}

func flattenCredentialUpdateSlice(objs *[]restapi.CredentialUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCredentialUpdate(&v))
	}
	return sl
}

func expandCredentialUpdate(in interface{}) *restapi.CredentialUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.CredentialUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["acl"]; ok {
		obj.ACL = expandStringSlice(v)
	}
	return &obj
}

func expandCredentialUpdateSlice(in interface{}) *[]restapi.CredentialUpdate {
	var out []restapi.CredentialUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCredentialUpdate(v))
	}
	return &out
}

func flattenCredential(obj *restapi.Credential) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["token"] = *obj.Token
	m["acl"] = obj.ACL

	return []interface{}{m}
}

func flattenCredentialSlice(objs *[]restapi.Credential) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCredential(&v))
	}
	return sl
}

func expandCredential(in interface{}) *restapi.Credential {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Credential
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["token"]; ok {
		obj.Token = expandString(v)
	}
	if v, ok := m["acl"]; ok {
		obj.ACL = *expandStringSlice(v)
	}
	return &obj
}

func expandCredentialSlice(in interface{}) *[]restapi.Credential {
	var out []restapi.Credential
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCredential(v))
	}
	return &out
}

func flattenCredentialList(obj *restapi.CredentialList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["credentials"] = flattenCredentialSlice(&obj.Credentials)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenCredentialListSlice(objs *[]restapi.CredentialList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCredentialList(&v))
	}
	return sl
}

func expandCredentialList(in interface{}) *restapi.CredentialList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.CredentialList
	if v, ok := m["credentials"]; ok {
		obj.Credentials = *expandCredentialSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandCredentialListSlice(in interface{}) *[]restapi.CredentialList {
	var out []restapi.CredentialList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCredentialList(v))
	}
	return &out
}

func flattenIPPolicyCreate(obj *restapi.IPPolicyCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["action"] = obj.Action

	return []interface{}{m}
}

func flattenIPPolicyCreateSlice(objs *[]restapi.IPPolicyCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPPolicyCreate(&v))
	}
	return sl
}

func expandIPPolicyCreate(in interface{}) *restapi.IPPolicyCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPPolicyCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["action"]; ok {
		obj.Action = *expandString(v)
	}
	return &obj
}

func expandIPPolicyCreateSlice(in interface{}) *[]restapi.IPPolicyCreate {
	var out []restapi.IPPolicyCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPPolicyCreate(v))
	}
	return &out
}

func flattenIPPolicyUpdate(obj *restapi.IPPolicyUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata

	return []interface{}{m}
}

func flattenIPPolicyUpdateSlice(objs *[]restapi.IPPolicyUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPPolicyUpdate(&v))
	}
	return sl
}

func expandIPPolicyUpdate(in interface{}) *restapi.IPPolicyUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPPolicyUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	return &obj
}

func expandIPPolicyUpdateSlice(in interface{}) *[]restapi.IPPolicyUpdate {
	var out []restapi.IPPolicyUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPPolicyUpdate(v))
	}
	return &out
}

func flattenIPPolicy(obj *restapi.IPPolicy) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["action"] = obj.Action

	return []interface{}{m}
}

func flattenIPPolicySlice(objs *[]restapi.IPPolicy) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPPolicy(&v))
	}
	return sl
}

func expandIPPolicy(in interface{}) *restapi.IPPolicy {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPPolicy
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["action"]; ok {
		obj.Action = *expandString(v)
	}
	return &obj
}

func expandIPPolicySlice(in interface{}) *[]restapi.IPPolicy {
	var out []restapi.IPPolicy
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPPolicy(v))
	}
	return &out
}

func flattenIPPolicyList(obj *restapi.IPPolicyList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ip_policies"] = flattenIPPolicySlice(&obj.IPPolicies)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenIPPolicyListSlice(objs *[]restapi.IPPolicyList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPPolicyList(&v))
	}
	return sl
}

func expandIPPolicyList(in interface{}) *restapi.IPPolicyList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPPolicyList
	if v, ok := m["ip_policies"]; ok {
		obj.IPPolicies = *expandIPPolicySlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandIPPolicyListSlice(in interface{}) *[]restapi.IPPolicyList {
	var out []restapi.IPPolicyList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPPolicyList(v))
	}
	return &out
}

func flattenIPPolicyRuleCreate(obj *restapi.IPPolicyRuleCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["cidr"] = obj.CIDR
	m["ip_policy_id"] = obj.IPPolicyID

	return []interface{}{m}
}

func flattenIPPolicyRuleCreateSlice(objs *[]restapi.IPPolicyRuleCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPPolicyRuleCreate(&v))
	}
	return sl
}

func expandIPPolicyRuleCreate(in interface{}) *restapi.IPPolicyRuleCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPPolicyRuleCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["cidr"]; ok {
		obj.CIDR = *expandString(v)
	}
	if v, ok := m["ip_policy_id"]; ok {
		obj.IPPolicyID = *expandString(v)
	}
	return &obj
}

func expandIPPolicyRuleCreateSlice(in interface{}) *[]restapi.IPPolicyRuleCreate {
	var out []restapi.IPPolicyRuleCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPPolicyRuleCreate(v))
	}
	return &out
}

func flattenIPPolicyRuleUpdate(obj *restapi.IPPolicyRuleUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata
	m["cidr"] = *obj.CIDR

	return []interface{}{m}
}

func flattenIPPolicyRuleUpdateSlice(objs *[]restapi.IPPolicyRuleUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPPolicyRuleUpdate(&v))
	}
	return sl
}

func expandIPPolicyRuleUpdate(in interface{}) *restapi.IPPolicyRuleUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPPolicyRuleUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["cidr"]; ok {
		obj.CIDR = expandString(v)
	}
	return &obj
}

func expandIPPolicyRuleUpdateSlice(in interface{}) *[]restapi.IPPolicyRuleUpdate {
	var out []restapi.IPPolicyRuleUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPPolicyRuleUpdate(v))
	}
	return &out
}

func flattenIPPolicyRule(obj *restapi.IPPolicyRule) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["cidr"] = obj.CIDR
	m["ip_policy"] = flattenRef(&obj.IPPolicy)

	return []interface{}{m}
}

func flattenIPPolicyRuleSlice(objs *[]restapi.IPPolicyRule) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPPolicyRule(&v))
	}
	return sl
}

func expandIPPolicyRule(in interface{}) *restapi.IPPolicyRule {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPPolicyRule
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["cidr"]; ok {
		obj.CIDR = *expandString(v)
	}
	if v, ok := m["ip_policy"]; ok {
		obj.IPPolicy = *expandRef(v)
	}
	return &obj
}

func expandIPPolicyRuleSlice(in interface{}) *[]restapi.IPPolicyRule {
	var out []restapi.IPPolicyRule
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPPolicyRule(v))
	}
	return &out
}

func flattenIPPolicyRuleList(obj *restapi.IPPolicyRuleList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ip_policy_rules"] = flattenIPPolicyRuleSlice(&obj.IPPolicyRules)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenIPPolicyRuleListSlice(objs *[]restapi.IPPolicyRuleList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPPolicyRuleList(&v))
	}
	return sl
}

func expandIPPolicyRuleList(in interface{}) *restapi.IPPolicyRuleList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPPolicyRuleList
	if v, ok := m["ip_policy_rules"]; ok {
		obj.IPPolicyRules = *expandIPPolicyRuleSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandIPPolicyRuleListSlice(in interface{}) *[]restapi.IPPolicyRuleList {
	var out []restapi.IPPolicyRuleList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPPolicyRuleList(v))
	}
	return &out
}

func flattenIPRestrictionCreate(obj *restapi.IPRestrictionCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["enforced"] = obj.Enforced
	m["type"] = obj.Type
	m["ip_policy_ids"] = obj.IPPolicyIDs

	return []interface{}{m}
}

func flattenIPRestrictionCreateSlice(objs *[]restapi.IPRestrictionCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPRestrictionCreate(&v))
	}
	return sl
}

func expandIPRestrictionCreate(in interface{}) *restapi.IPRestrictionCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPRestrictionCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["enforced"]; ok {
		obj.Enforced = *expandBool(v)
	}
	if v, ok := m["type"]; ok {
		obj.Type = *expandString(v)
	}
	if v, ok := m["ip_policy_ids"]; ok {
		obj.IPPolicyIDs = *expandStringSlice(v)
	}
	return &obj
}

func expandIPRestrictionCreateSlice(in interface{}) *[]restapi.IPRestrictionCreate {
	var out []restapi.IPRestrictionCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPRestrictionCreate(v))
	}
	return &out
}

func flattenIPRestrictionUpdate(obj *restapi.IPRestrictionUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata
	m["enforced"] = *obj.Enforced
	m["ip_policy_ids"] = obj.IPPolicyIDs

	return []interface{}{m}
}

func flattenIPRestrictionUpdateSlice(objs *[]restapi.IPRestrictionUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPRestrictionUpdate(&v))
	}
	return sl
}

func expandIPRestrictionUpdate(in interface{}) *restapi.IPRestrictionUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPRestrictionUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["enforced"]; ok {
		obj.Enforced = expandBool(v)
	}
	if v, ok := m["ip_policy_ids"]; ok {
		obj.IPPolicyIDs = *expandStringSlice(v)
	}
	return &obj
}

func expandIPRestrictionUpdateSlice(in interface{}) *[]restapi.IPRestrictionUpdate {
	var out []restapi.IPRestrictionUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPRestrictionUpdate(v))
	}
	return &out
}

func flattenIPRestriction(obj *restapi.IPRestriction) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["enforced"] = obj.Enforced
	m["type"] = obj.Type
	m["ip_policies"] = flattenRefSlice(&obj.IPPolicies)

	return []interface{}{m}
}

func flattenIPRestrictionSlice(objs *[]restapi.IPRestriction) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPRestriction(&v))
	}
	return sl
}

func expandIPRestriction(in interface{}) *restapi.IPRestriction {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPRestriction
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["enforced"]; ok {
		obj.Enforced = *expandBool(v)
	}
	if v, ok := m["type"]; ok {
		obj.Type = *expandString(v)
	}
	if v, ok := m["ip_policies"]; ok {
		obj.IPPolicies = *expandRefSlice(v)
	}
	return &obj
}

func expandIPRestrictionSlice(in interface{}) *[]restapi.IPRestriction {
	var out []restapi.IPRestriction
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPRestriction(v))
	}
	return &out
}

func flattenIPRestrictionList(obj *restapi.IPRestrictionList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ip_restrictions"] = flattenIPRestrictionSlice(&obj.IPRestrictions)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenIPRestrictionListSlice(objs *[]restapi.IPRestrictionList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPRestrictionList(&v))
	}
	return sl
}

func expandIPRestrictionList(in interface{}) *restapi.IPRestrictionList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPRestrictionList
	if v, ok := m["ip_restrictions"]; ok {
		obj.IPRestrictions = *expandIPRestrictionSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandIPRestrictionListSlice(in interface{}) *[]restapi.IPRestrictionList {
	var out []restapi.IPRestrictionList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPRestrictionList(v))
	}
	return &out
}

func flattenIPWhitelistEntryCreate(obj *restapi.IPWhitelistEntryCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["ip_net"] = obj.IPNet

	return []interface{}{m}
}

func flattenIPWhitelistEntryCreateSlice(objs *[]restapi.IPWhitelistEntryCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPWhitelistEntryCreate(&v))
	}
	return sl
}

func expandIPWhitelistEntryCreate(in interface{}) *restapi.IPWhitelistEntryCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPWhitelistEntryCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["ip_net"]; ok {
		obj.IPNet = *expandString(v)
	}
	return &obj
}

func expandIPWhitelistEntryCreateSlice(in interface{}) *[]restapi.IPWhitelistEntryCreate {
	var out []restapi.IPWhitelistEntryCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPWhitelistEntryCreate(v))
	}
	return &out
}

func flattenIPWhitelistEntryUpdate(obj *restapi.IPWhitelistEntryUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata

	return []interface{}{m}
}

func flattenIPWhitelistEntryUpdateSlice(objs *[]restapi.IPWhitelistEntryUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPWhitelistEntryUpdate(&v))
	}
	return sl
}

func expandIPWhitelistEntryUpdate(in interface{}) *restapi.IPWhitelistEntryUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPWhitelistEntryUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	return &obj
}

func expandIPWhitelistEntryUpdateSlice(in interface{}) *[]restapi.IPWhitelistEntryUpdate {
	var out []restapi.IPWhitelistEntryUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPWhitelistEntryUpdate(v))
	}
	return &out
}

func flattenIPWhitelistEntry(obj *restapi.IPWhitelistEntry) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["ip_net"] = obj.IPNet

	return []interface{}{m}
}

func flattenIPWhitelistEntrySlice(objs *[]restapi.IPWhitelistEntry) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPWhitelistEntry(&v))
	}
	return sl
}

func expandIPWhitelistEntry(in interface{}) *restapi.IPWhitelistEntry {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPWhitelistEntry
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["ip_net"]; ok {
		obj.IPNet = *expandString(v)
	}
	return &obj
}

func expandIPWhitelistEntrySlice(in interface{}) *[]restapi.IPWhitelistEntry {
	var out []restapi.IPWhitelistEntry
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPWhitelistEntry(v))
	}
	return &out
}

func flattenIPWhitelistEntryList(obj *restapi.IPWhitelistEntryList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["whitelist"] = flattenIPWhitelistEntrySlice(&obj.Whitelist)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenIPWhitelistEntryListSlice(objs *[]restapi.IPWhitelistEntryList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenIPWhitelistEntryList(&v))
	}
	return sl
}

func expandIPWhitelistEntryList(in interface{}) *restapi.IPWhitelistEntryList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.IPWhitelistEntryList
	if v, ok := m["whitelist"]; ok {
		obj.Whitelist = *expandIPWhitelistEntrySlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandIPWhitelistEntryListSlice(in interface{}) *[]restapi.IPWhitelistEntryList {
	var out []restapi.IPWhitelistEntryList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandIPWhitelistEntryList(v))
	}
	return &out
}

func flattenLogConfigCreate(obj *restapi.LogConfigCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["metadata"] = obj.Metadata
	m["description"] = obj.Description
	m["fields"] = obj.Fields
	m["event_type"] = obj.EventType
	m["destination_ids"] = obj.DestinationIDs
	m["sampling_rate"] = obj.SamplingRate

	return []interface{}{m}
}

func flattenLogConfigCreateSlice(objs *[]restapi.LogConfigCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogConfigCreate(&v))
	}
	return sl
}

func expandLogConfigCreate(in interface{}) *restapi.LogConfigCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogConfigCreate
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["fields"]; ok {
		obj.Fields = *expandStringSlice(v)
	}
	if v, ok := m["event_type"]; ok {
		obj.EventType = *expandString(v)
	}
	if v, ok := m["destination_ids"]; ok {
		obj.DestinationIDs = *expandStringSlice(v)
	}
	if v, ok := m["sampling_rate"]; ok {
		obj.SamplingRate = *expandFloat64(v)
	}
	return &obj
}

func expandLogConfigCreateSlice(in interface{}) *[]restapi.LogConfigCreate {
	var out []restapi.LogConfigCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogConfigCreate(v))
	}
	return &out
}

func flattenLogConfigUpdate(obj *restapi.LogConfigUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["metadata"] = *obj.Metadata
	m["description"] = *obj.Description
	m["fields"] = *obj.Fields
	m["destination_ids"] = *obj.DestinationIDs
	m["sampling_rate"] = *obj.SamplingRate

	return []interface{}{m}
}

func flattenLogConfigUpdateSlice(objs *[]restapi.LogConfigUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogConfigUpdate(&v))
	}
	return sl
}

func expandLogConfigUpdate(in interface{}) *restapi.LogConfigUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogConfigUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["fields"]; ok {
		obj.Fields = expandStringSlice(v)
	}
	if v, ok := m["destination_ids"]; ok {
		obj.DestinationIDs = expandStringSlice(v)
	}
	if v, ok := m["sampling_rate"]; ok {
		obj.SamplingRate = expandFloat64(v)
	}
	return &obj
}

func expandLogConfigUpdateSlice(in interface{}) *[]restapi.LogConfigUpdate {
	var out []restapi.LogConfigUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogConfigUpdate(v))
	}
	return &out
}

func flattenLogConfigList(obj *restapi.LogConfigList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["log_configs"] = flattenLogConfigSlice(&obj.LogConfigs)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenLogConfigListSlice(objs *[]restapi.LogConfigList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogConfigList(&v))
	}
	return sl
}

func expandLogConfigList(in interface{}) *restapi.LogConfigList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogConfigList
	if v, ok := m["log_configs"]; ok {
		obj.LogConfigs = *expandLogConfigSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandLogConfigListSlice(in interface{}) *[]restapi.LogConfigList {
	var out []restapi.LogConfigList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogConfigList(v))
	}
	return &out
}

func flattenLogConfig(obj *restapi.LogConfig) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["metadata"] = obj.Metadata
	m["description"] = obj.Description
	m["fields"] = obj.Fields
	m["event_type"] = obj.EventType
	m["destination_ids"] = obj.DestinationIDs
	m["sampling_rate"] = obj.SamplingRate

	return []interface{}{m}
}

func flattenLogConfigSlice(objs *[]restapi.LogConfig) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogConfig(&v))
	}
	return sl
}

func expandLogConfig(in interface{}) *restapi.LogConfig {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogConfig
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["fields"]; ok {
		obj.Fields = *expandStringSlice(v)
	}
	if v, ok := m["event_type"]; ok {
		obj.EventType = *expandString(v)
	}
	if v, ok := m["destination_ids"]; ok {
		obj.DestinationIDs = *expandStringSlice(v)
	}
	if v, ok := m["sampling_rate"]; ok {
		obj.SamplingRate = *expandFloat64(v)
	}
	return &obj
}

func expandLogConfigSlice(in interface{}) *[]restapi.LogConfig {
	var out []restapi.LogConfig
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogConfig(v))
	}
	return &out
}

func flattenLogDestinationCreate(obj *restapi.LogDestinationCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["metadata"] = obj.Metadata
	m["description"] = obj.Description
	m["format"] = obj.Format
	m["target"] = flattenLogDestinationTarget(&obj.Target)

	return []interface{}{m}
}

func flattenLogDestinationCreateSlice(objs *[]restapi.LogDestinationCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogDestinationCreate(&v))
	}
	return sl
}

func expandLogDestinationCreate(in interface{}) *restapi.LogDestinationCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogDestinationCreate
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["format"]; ok {
		obj.Format = *expandString(v)
	}
	if v, ok := m["target"]; ok {
		obj.Target = *expandLogDestinationTarget(v)
	}
	return &obj
}

func expandLogDestinationCreateSlice(in interface{}) *[]restapi.LogDestinationCreate {
	var out []restapi.LogDestinationCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogDestinationCreate(v))
	}
	return &out
}

func flattenLogDestinationUpdate(obj *restapi.LogDestinationUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["metadata"] = *obj.Metadata
	m["description"] = *obj.Description
	m["format"] = *obj.Format
	m["target"] = flattenLogDestinationTarget(obj.Target)

	return []interface{}{m}
}

func flattenLogDestinationUpdateSlice(objs *[]restapi.LogDestinationUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogDestinationUpdate(&v))
	}
	return sl
}

func expandLogDestinationUpdate(in interface{}) *restapi.LogDestinationUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogDestinationUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["format"]; ok {
		obj.Format = expandString(v)
	}
	if v, ok := m["target"]; ok {
		obj.Target = expandLogDestinationTarget(v)
	}
	return &obj
}

func expandLogDestinationUpdateSlice(in interface{}) *[]restapi.LogDestinationUpdate {
	var out []restapi.LogDestinationUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogDestinationUpdate(v))
	}
	return &out
}

func flattenLogDestination(obj *restapi.LogDestination) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["metadata"] = obj.Metadata
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["format"] = obj.Format
	m["target"] = flattenLogDestinationTarget(&obj.Target)
	m["uri"] = obj.URI

	return []interface{}{m}
}

func flattenLogDestinationSlice(objs *[]restapi.LogDestination) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogDestination(&v))
	}
	return sl
}

func expandLogDestination(in interface{}) *restapi.LogDestination {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogDestination
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["format"]; ok {
		obj.Format = *expandString(v)
	}
	if v, ok := m["target"]; ok {
		obj.Target = *expandLogDestinationTarget(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	return &obj
}

func expandLogDestinationSlice(in interface{}) *[]restapi.LogDestination {
	var out []restapi.LogDestination
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogDestination(v))
	}
	return &out
}

func flattenLogDestinationList(obj *restapi.LogDestinationList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["log_destinations"] = flattenLogDestinationSlice(&obj.LogDestinations)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenLogDestinationListSlice(objs *[]restapi.LogDestinationList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogDestinationList(&v))
	}
	return sl
}

func expandLogDestinationList(in interface{}) *restapi.LogDestinationList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogDestinationList
	if v, ok := m["log_destinations"]; ok {
		obj.LogDestinations = *expandLogDestinationSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandLogDestinationListSlice(in interface{}) *[]restapi.LogDestinationList {
	var out []restapi.LogDestinationList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogDestinationList(v))
	}
	return &out
}

func flattenLogDestinationTarget(obj *restapi.LogDestinationTarget) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["firehose"] = flattenFirehose(obj.Firehose)
	m["kinesis"] = flattenKinesis(obj.Kinesis)
	m["cloudwatch"] = flattenCloudwatch(obj.Cloudwatch)
	m["debug"] = flattenEventTargetDebug(obj.Debug)

	return []interface{}{m}
}

func flattenLogDestinationTargetSlice(objs *[]restapi.LogDestinationTarget) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenLogDestinationTarget(&v))
	}
	return sl
}

func expandLogDestinationTarget(in interface{}) *restapi.LogDestinationTarget {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.LogDestinationTarget
	if v, ok := m["firehose"]; ok {
		obj.Firehose = expandFirehose(v)
	}
	if v, ok := m["kinesis"]; ok {
		obj.Kinesis = expandKinesis(v)
	}
	if v, ok := m["cloudwatch"]; ok {
		obj.Cloudwatch = expandCloudwatch(v)
	}
	if v, ok := m["debug"]; ok {
		obj.Debug = expandEventTargetDebug(v)
	}
	return &obj
}

func expandLogDestinationTargetSlice(in interface{}) *[]restapi.LogDestinationTarget {
	var out []restapi.LogDestinationTarget
	for _, v := range in.([]interface{}) {
		out = append(out, *expandLogDestinationTarget(v))
	}
	return &out
}

func flattenFirehose(obj *restapi.Firehose) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["auth"] = flattenAWSAuth(&obj.Auth)
	m["delivery_stream_arn"] = obj.DeliveryStreamARN

	return []interface{}{m}
}

func flattenFirehoseSlice(objs *[]restapi.Firehose) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenFirehose(&v))
	}
	return sl
}

func expandFirehose(in interface{}) *restapi.Firehose {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Firehose
	if v, ok := m["auth"]; ok {
		obj.Auth = *expandAWSAuth(v)
	}
	if v, ok := m["delivery_stream_arn"]; ok {
		obj.DeliveryStreamARN = *expandString(v)
	}
	return &obj
}

func expandFirehoseSlice(in interface{}) *[]restapi.Firehose {
	var out []restapi.Firehose
	for _, v := range in.([]interface{}) {
		out = append(out, *expandFirehose(v))
	}
	return &out
}

func flattenKinesis(obj *restapi.Kinesis) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["auth"] = flattenAWSAuth(&obj.Auth)
	m["stream_arn"] = obj.StreamARN

	return []interface{}{m}
}

func flattenKinesisSlice(objs *[]restapi.Kinesis) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenKinesis(&v))
	}
	return sl
}

func expandKinesis(in interface{}) *restapi.Kinesis {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Kinesis
	if v, ok := m["auth"]; ok {
		obj.Auth = *expandAWSAuth(v)
	}
	if v, ok := m["stream_arn"]; ok {
		obj.StreamARN = *expandString(v)
	}
	return &obj
}

func expandKinesisSlice(in interface{}) *[]restapi.Kinesis {
	var out []restapi.Kinesis
	for _, v := range in.([]interface{}) {
		out = append(out, *expandKinesis(v))
	}
	return &out
}

func flattenCloudwatch(obj *restapi.Cloudwatch) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["auth"] = flattenAWSAuth(&obj.Auth)
	m["log_group_arn"] = obj.LogGroupARN

	return []interface{}{m}
}

func flattenCloudwatchSlice(objs *[]restapi.Cloudwatch) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenCloudwatch(&v))
	}
	return sl
}

func expandCloudwatch(in interface{}) *restapi.Cloudwatch {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Cloudwatch
	if v, ok := m["auth"]; ok {
		obj.Auth = *expandAWSAuth(v)
	}
	if v, ok := m["log_group_arn"]; ok {
		obj.LogGroupARN = *expandString(v)
	}
	return &obj
}

func expandCloudwatchSlice(in interface{}) *[]restapi.Cloudwatch {
	var out []restapi.Cloudwatch
	for _, v := range in.([]interface{}) {
		out = append(out, *expandCloudwatch(v))
	}
	return &out
}

func flattenS3(obj *restapi.S3) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["auth"] = flattenAWSAuth(&obj.Auth)
	m["bucket_arn"] = obj.BucketARN
	m["object_prefix"] = obj.ObjectPrefix
	m["compression"] = obj.Compression
	m["max_file_size"] = obj.MaxFileSize
	m["max_file_age"] = obj.MaxFileAge

	return []interface{}{m}
}

func flattenS3Slice(objs *[]restapi.S3) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenS3(&v))
	}
	return sl
}

func expandS3(in interface{}) *restapi.S3 {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.S3
	if v, ok := m["auth"]; ok {
		obj.Auth = *expandAWSAuth(v)
	}
	if v, ok := m["bucket_arn"]; ok {
		obj.BucketARN = *expandString(v)
	}
	if v, ok := m["object_prefix"]; ok {
		obj.ObjectPrefix = *expandString(v)
	}
	if v, ok := m["compression"]; ok {
		obj.Compression = *expandBool(v)
	}
	if v, ok := m["max_file_size"]; ok {
		obj.MaxFileSize = *expandInt64(v)
	}
	if v, ok := m["max_file_age"]; ok {
		obj.MaxFileAge = *expandInt64(v)
	}
	return &obj
}

func expandS3Slice(in interface{}) *[]restapi.S3 {
	var out []restapi.S3
	for _, v := range in.([]interface{}) {
		out = append(out, *expandS3(v))
	}
	return &out
}

func flattenEventTargetDebug(obj *restapi.EventTargetDebug) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["log"] = obj.Log
	m["callback_url"] = obj.CallbackURL

	return []interface{}{m}
}

func flattenEventTargetDebugSlice(objs *[]restapi.EventTargetDebug) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEventTargetDebug(&v))
	}
	return sl
}

func expandEventTargetDebug(in interface{}) *restapi.EventTargetDebug {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EventTargetDebug
	if v, ok := m["log"]; ok {
		obj.Log = *expandBool(v)
	}
	if v, ok := m["callback_url"]; ok {
		obj.CallbackURL = *expandString(v)
	}
	return &obj
}

func expandEventTargetDebugSlice(in interface{}) *[]restapi.EventTargetDebug {
	var out []restapi.EventTargetDebug
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEventTargetDebug(v))
	}
	return &out
}

func flattenAWSAuth(obj *restapi.AWSAuth) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["role"] = flattenAWSRole(obj.Role)
	m["creds"] = flattenAWSCredentials(obj.Creds)

	return []interface{}{m}
}

func flattenAWSAuthSlice(objs *[]restapi.AWSAuth) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAWSAuth(&v))
	}
	return sl
}

func expandAWSAuth(in interface{}) *restapi.AWSAuth {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.AWSAuth
	if v, ok := m["role"]; ok {
		obj.Role = expandAWSRole(v)
	}
	if v, ok := m["creds"]; ok {
		obj.Creds = expandAWSCredentials(v)
	}
	return &obj
}

func expandAWSAuthSlice(in interface{}) *[]restapi.AWSAuth {
	var out []restapi.AWSAuth
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAWSAuth(v))
	}
	return &out
}

func flattenAWSRole(obj *restapi.AWSRole) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["arn"] = obj.ARN

	return []interface{}{m}
}

func flattenAWSRoleSlice(objs *[]restapi.AWSRole) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAWSRole(&v))
	}
	return sl
}

func expandAWSRole(in interface{}) *restapi.AWSRole {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.AWSRole
	if v, ok := m["arn"]; ok {
		obj.ARN = *expandString(v)
	}
	return &obj
}

func expandAWSRoleSlice(in interface{}) *[]restapi.AWSRole {
	var out []restapi.AWSRole
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAWSRole(v))
	}
	return &out
}

func flattenAWSCredentials(obj *restapi.AWSCredentials) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["aws_access_key_id"] = obj.AWSAccessKeyID
	m["aws_secret_access_key"] = *obj.AWSSecretAccessKey

	return []interface{}{m}
}

func flattenAWSCredentialsSlice(objs *[]restapi.AWSCredentials) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenAWSCredentials(&v))
	}
	return sl
}

func expandAWSCredentials(in interface{}) *restapi.AWSCredentials {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.AWSCredentials
	if v, ok := m["aws_access_key_id"]; ok {
		obj.AWSAccessKeyID = *expandString(v)
	}
	if v, ok := m["aws_secret_access_key"]; ok {
		obj.AWSSecretAccessKey = expandString(v)
	}
	return &obj
}

func expandAWSCredentialsSlice(in interface{}) *[]restapi.AWSCredentials {
	var out []restapi.AWSCredentials
	for _, v := range in.([]interface{}) {
		out = append(out, *expandAWSCredentials(v))
	}
	return &out
}

func flattenEndpointConfiguration(obj *restapi.EndpointConfiguration) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["type"] = obj.Type
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["created_at"] = obj.CreatedAt
	m["uri"] = obj.URI
	m["basic_auth"] = flattenEndpointBasicAuth(obj.BasicAuth)
	m["circuit_breaker"] = flattenEndpointCircuitBreaker(obj.CircuitBreaker)
	m["compression"] = flattenEndpointCompression(obj.Compression)
	m["request_headers"] = flattenEndpointRequestHeaders(obj.RequestHeaders)
	m["response_headers"] = flattenEndpointResponseHeaders(obj.ResponseHeaders)
	m["ip_policy"] = flattenEndpointIPPolicy(obj.IPPolicy)
	m["mutual_tls"] = flattenEndpointMutualTLS(obj.MutualTLS)
	m["tls_termination"] = flattenEndpointTLSTermination(obj.TLSTermination)
	m["webhook_validation"] = flattenEndpointWebhookValidation(obj.WebhookValidation)
	m["oauth"] = flattenEndpointOAuth(obj.OAuth)
	m["logging"] = flattenEndpointLogging(obj.Logging)
	m["saml"] = flattenEndpointSAML(obj.SAML)
	m["oidc"] = flattenEndpointOIDC(obj.OIDC)

	return []interface{}{m}
}

func flattenEndpointConfigurationSlice(objs *[]restapi.EndpointConfiguration) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointConfiguration(&v))
	}
	return sl
}

func expandEndpointConfiguration(in interface{}) *restapi.EndpointConfiguration {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointConfiguration
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["type"]; ok {
		obj.Type = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["basic_auth"]; ok {
		obj.BasicAuth = expandEndpointBasicAuth(v)
	}
	if v, ok := m["circuit_breaker"]; ok {
		obj.CircuitBreaker = expandEndpointCircuitBreaker(v)
	}
	if v, ok := m["compression"]; ok {
		obj.Compression = expandEndpointCompression(v)
	}
	if v, ok := m["request_headers"]; ok {
		obj.RequestHeaders = expandEndpointRequestHeaders(v)
	}
	if v, ok := m["response_headers"]; ok {
		obj.ResponseHeaders = expandEndpointResponseHeaders(v)
	}
	if v, ok := m["ip_policy"]; ok {
		obj.IPPolicy = expandEndpointIPPolicy(v)
	}
	if v, ok := m["mutual_tls"]; ok {
		obj.MutualTLS = expandEndpointMutualTLS(v)
	}
	if v, ok := m["tls_termination"]; ok {
		obj.TLSTermination = expandEndpointTLSTermination(v)
	}
	if v, ok := m["webhook_validation"]; ok {
		obj.WebhookValidation = expandEndpointWebhookValidation(v)
	}
	if v, ok := m["oauth"]; ok {
		obj.OAuth = expandEndpointOAuth(v)
	}
	if v, ok := m["logging"]; ok {
		obj.Logging = expandEndpointLogging(v)
	}
	if v, ok := m["saml"]; ok {
		obj.SAML = expandEndpointSAML(v)
	}
	if v, ok := m["oidc"]; ok {
		obj.OIDC = expandEndpointOIDC(v)
	}
	return &obj
}

func expandEndpointConfigurationSlice(in interface{}) *[]restapi.EndpointConfiguration {
	var out []restapi.EndpointConfiguration
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointConfiguration(v))
	}
	return &out
}

func flattenEndpointConfigurationList(obj *restapi.EndpointConfigurationList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["endpoint_configurations"] = flattenEndpointConfigurationSlice(&obj.EndpointConfigurations)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenEndpointConfigurationListSlice(objs *[]restapi.EndpointConfigurationList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointConfigurationList(&v))
	}
	return sl
}

func expandEndpointConfigurationList(in interface{}) *restapi.EndpointConfigurationList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointConfigurationList
	if v, ok := m["endpoint_configurations"]; ok {
		obj.EndpointConfigurations = *expandEndpointConfigurationSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandEndpointConfigurationListSlice(in interface{}) *[]restapi.EndpointConfigurationList {
	var out []restapi.EndpointConfigurationList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointConfigurationList(v))
	}
	return &out
}

func flattenEndpointConfigurationUpdate(obj *restapi.EndpointConfigurationUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata
	m["basic_auth"] = flattenEndpointBasicAuth(obj.BasicAuth)
	m["circuit_breaker"] = flattenEndpointCircuitBreaker(obj.CircuitBreaker)
	m["compression"] = flattenEndpointCompression(obj.Compression)
	m["request_headers"] = flattenEndpointRequestHeaders(obj.RequestHeaders)
	m["response_headers"] = flattenEndpointResponseHeaders(obj.ResponseHeaders)
	m["ip_policy"] = flattenEndpointIPPolicyMutate(obj.IPPolicy)
	m["mutual_tls"] = flattenEndpointMutualTLSMutate(obj.MutualTLS)
	m["tls_termination"] = flattenEndpointTLSTermination(obj.TLSTermination)
	m["webhook_validation"] = flattenEndpointWebhookValidation(obj.WebhookValidation)
	m["oauth"] = flattenEndpointOAuth(obj.OAuth)
	m["logging"] = flattenEndpointLoggingMutate(obj.Logging)
	m["saml"] = flattenEndpointSAMLMutate(obj.SAML)
	m["oidc"] = flattenEndpointOIDC(obj.OIDC)

	return []interface{}{m}
}

func flattenEndpointConfigurationUpdateSlice(objs *[]restapi.EndpointConfigurationUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointConfigurationUpdate(&v))
	}
	return sl
}

func expandEndpointConfigurationUpdate(in interface{}) *restapi.EndpointConfigurationUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointConfigurationUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["basic_auth"]; ok {
		obj.BasicAuth = expandEndpointBasicAuth(v)
	}
	if v, ok := m["circuit_breaker"]; ok {
		obj.CircuitBreaker = expandEndpointCircuitBreaker(v)
	}
	if v, ok := m["compression"]; ok {
		obj.Compression = expandEndpointCompression(v)
	}
	if v, ok := m["request_headers"]; ok {
		obj.RequestHeaders = expandEndpointRequestHeaders(v)
	}
	if v, ok := m["response_headers"]; ok {
		obj.ResponseHeaders = expandEndpointResponseHeaders(v)
	}
	if v, ok := m["ip_policy"]; ok {
		obj.IPPolicy = expandEndpointIPPolicyMutate(v)
	}
	if v, ok := m["mutual_tls"]; ok {
		obj.MutualTLS = expandEndpointMutualTLSMutate(v)
	}
	if v, ok := m["tls_termination"]; ok {
		obj.TLSTermination = expandEndpointTLSTermination(v)
	}
	if v, ok := m["webhook_validation"]; ok {
		obj.WebhookValidation = expandEndpointWebhookValidation(v)
	}
	if v, ok := m["oauth"]; ok {
		obj.OAuth = expandEndpointOAuth(v)
	}
	if v, ok := m["logging"]; ok {
		obj.Logging = expandEndpointLoggingMutate(v)
	}
	if v, ok := m["saml"]; ok {
		obj.SAML = expandEndpointSAMLMutate(v)
	}
	if v, ok := m["oidc"]; ok {
		obj.OIDC = expandEndpointOIDC(v)
	}
	return &obj
}

func expandEndpointConfigurationUpdateSlice(in interface{}) *[]restapi.EndpointConfigurationUpdate {
	var out []restapi.EndpointConfigurationUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointConfigurationUpdate(v))
	}
	return &out
}

func flattenEndpointConfigurationCreate(obj *restapi.EndpointConfigurationCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["type"] = obj.Type
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["basic_auth"] = flattenEndpointBasicAuth(obj.BasicAuth)
	m["circuit_breaker"] = flattenEndpointCircuitBreaker(obj.CircuitBreaker)
	m["compression"] = flattenEndpointCompression(obj.Compression)
	m["request_headers"] = flattenEndpointRequestHeaders(obj.RequestHeaders)
	m["response_headers"] = flattenEndpointResponseHeaders(obj.ResponseHeaders)
	m["ip_policy"] = flattenEndpointIPPolicyMutate(obj.IPPolicy)
	m["mutual_tls"] = flattenEndpointMutualTLSMutate(obj.MutualTLS)
	m["tls_termination"] = flattenEndpointTLSTermination(obj.TLSTermination)
	m["webhook_validation"] = flattenEndpointWebhookValidation(obj.WebhookValidation)
	m["oauth"] = flattenEndpointOAuth(obj.OAuth)
	m["logging"] = flattenEndpointLoggingMutate(obj.Logging)
	m["saml"] = flattenEndpointSAMLMutate(obj.SAML)
	m["oidc"] = flattenEndpointOIDC(obj.OIDC)

	return []interface{}{m}
}

func flattenEndpointConfigurationCreateSlice(objs *[]restapi.EndpointConfigurationCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointConfigurationCreate(&v))
	}
	return sl
}

func expandEndpointConfigurationCreate(in interface{}) *restapi.EndpointConfigurationCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointConfigurationCreate
	if v, ok := m["type"]; ok {
		obj.Type = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["basic_auth"]; ok {
		obj.BasicAuth = expandEndpointBasicAuth(v)
	}
	if v, ok := m["circuit_breaker"]; ok {
		obj.CircuitBreaker = expandEndpointCircuitBreaker(v)
	}
	if v, ok := m["compression"]; ok {
		obj.Compression = expandEndpointCompression(v)
	}
	if v, ok := m["request_headers"]; ok {
		obj.RequestHeaders = expandEndpointRequestHeaders(v)
	}
	if v, ok := m["response_headers"]; ok {
		obj.ResponseHeaders = expandEndpointResponseHeaders(v)
	}
	if v, ok := m["ip_policy"]; ok {
		obj.IPPolicy = expandEndpointIPPolicyMutate(v)
	}
	if v, ok := m["mutual_tls"]; ok {
		obj.MutualTLS = expandEndpointMutualTLSMutate(v)
	}
	if v, ok := m["tls_termination"]; ok {
		obj.TLSTermination = expandEndpointTLSTermination(v)
	}
	if v, ok := m["webhook_validation"]; ok {
		obj.WebhookValidation = expandEndpointWebhookValidation(v)
	}
	if v, ok := m["oauth"]; ok {
		obj.OAuth = expandEndpointOAuth(v)
	}
	if v, ok := m["logging"]; ok {
		obj.Logging = expandEndpointLoggingMutate(v)
	}
	if v, ok := m["saml"]; ok {
		obj.SAML = expandEndpointSAMLMutate(v)
	}
	if v, ok := m["oidc"]; ok {
		obj.OIDC = expandEndpointOIDC(v)
	}
	return &obj
}

func expandEndpointConfigurationCreateSlice(in interface{}) *[]restapi.EndpointConfigurationCreate {
	var out []restapi.EndpointConfigurationCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointConfigurationCreate(v))
	}
	return &out
}

func flattenEndpointWebhookValidation(obj *restapi.EndpointWebhookValidation) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["provider"] = obj.Provider
	m["secret"] = obj.Secret

	return []interface{}{m}
}

func flattenEndpointWebhookValidationSlice(objs *[]restapi.EndpointWebhookValidation) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointWebhookValidation(&v))
	}
	return sl
}

func expandEndpointWebhookValidation(in interface{}) *restapi.EndpointWebhookValidation {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointWebhookValidation
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["provider"]; ok {
		obj.Provider = *expandString(v)
	}
	if v, ok := m["secret"]; ok {
		obj.Secret = *expandString(v)
	}
	return &obj
}

func expandEndpointWebhookValidationSlice(in interface{}) *[]restapi.EndpointWebhookValidation {
	var out []restapi.EndpointWebhookValidation
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointWebhookValidation(v))
	}
	return &out
}

func flattenEndpointCompression(obj *restapi.EndpointCompression) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled

	return []interface{}{m}
}

func flattenEndpointCompressionSlice(objs *[]restapi.EndpointCompression) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointCompression(&v))
	}
	return sl
}

func expandEndpointCompression(in interface{}) *restapi.EndpointCompression {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointCompression
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	return &obj
}

func expandEndpointCompressionSlice(in interface{}) *[]restapi.EndpointCompression {
	var out []restapi.EndpointCompression
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointCompression(v))
	}
	return &out
}

func flattenEndpointMutualTLS(obj *restapi.EndpointMutualTLS) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["certificate_authorities"] = flattenRefSlice(&obj.CertificateAuthorities)

	return []interface{}{m}
}

func flattenEndpointMutualTLSSlice(objs *[]restapi.EndpointMutualTLS) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointMutualTLS(&v))
	}
	return sl
}

func expandEndpointMutualTLS(in interface{}) *restapi.EndpointMutualTLS {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointMutualTLS
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["certificate_authorities"]; ok {
		obj.CertificateAuthorities = *expandRefSlice(v)
	}
	return &obj
}

func expandEndpointMutualTLSSlice(in interface{}) *[]restapi.EndpointMutualTLS {
	var out []restapi.EndpointMutualTLS
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointMutualTLS(v))
	}
	return &out
}

func flattenEndpointMutualTLSMutate(obj *restapi.EndpointMutualTLSMutate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["certificate_authority_ids"] = obj.CertificateAuthorityIDs

	return []interface{}{m}
}

func flattenEndpointMutualTLSMutateSlice(objs *[]restapi.EndpointMutualTLSMutate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointMutualTLSMutate(&v))
	}
	return sl
}

func expandEndpointMutualTLSMutate(in interface{}) *restapi.EndpointMutualTLSMutate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointMutualTLSMutate
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["certificate_authority_ids"]; ok {
		obj.CertificateAuthorityIDs = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointMutualTLSMutateSlice(in interface{}) *[]restapi.EndpointMutualTLSMutate {
	var out []restapi.EndpointMutualTLSMutate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointMutualTLSMutate(v))
	}
	return &out
}

func flattenEndpointTLSTermination(obj *restapi.EndpointTLSTermination) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["terminate_at"] = obj.TerminateAt
	m["min_version"] = *obj.MinVersion

	return []interface{}{m}
}

func flattenEndpointTLSTerminationSlice(objs *[]restapi.EndpointTLSTermination) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointTLSTermination(&v))
	}
	return sl
}

func expandEndpointTLSTermination(in interface{}) *restapi.EndpointTLSTermination {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointTLSTermination
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["terminate_at"]; ok {
		obj.TerminateAt = *expandString(v)
	}
	if v, ok := m["min_version"]; ok {
		obj.MinVersion = expandString(v)
	}
	return &obj
}

func expandEndpointTLSTerminationSlice(in interface{}) *[]restapi.EndpointTLSTermination {
	var out []restapi.EndpointTLSTermination
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointTLSTermination(v))
	}
	return &out
}

func flattenEndpointBasicAuth(obj *restapi.EndpointBasicAuth) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["auth_provider_id"] = obj.AuthProviderID
	m["realm"] = obj.Realm
	m["allow_options"] = obj.AllowOptions

	return []interface{}{m}
}

func flattenEndpointBasicAuthSlice(objs *[]restapi.EndpointBasicAuth) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointBasicAuth(&v))
	}
	return sl
}

func expandEndpointBasicAuth(in interface{}) *restapi.EndpointBasicAuth {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointBasicAuth
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["auth_provider_id"]; ok {
		obj.AuthProviderID = *expandString(v)
	}
	if v, ok := m["realm"]; ok {
		obj.Realm = *expandString(v)
	}
	if v, ok := m["allow_options"]; ok {
		obj.AllowOptions = *expandBool(v)
	}
	return &obj
}

func expandEndpointBasicAuthSlice(in interface{}) *[]restapi.EndpointBasicAuth {
	var out []restapi.EndpointBasicAuth
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointBasicAuth(v))
	}
	return &out
}

func flattenEndpointLogging(obj *restapi.EndpointLogging) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["log_configs"] = flattenRefSlice(&obj.LogConfigs)

	return []interface{}{m}
}

func flattenEndpointLoggingSlice(objs *[]restapi.EndpointLogging) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointLogging(&v))
	}
	return sl
}

func expandEndpointLogging(in interface{}) *restapi.EndpointLogging {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointLogging
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["log_configs"]; ok {
		obj.LogConfigs = *expandRefSlice(v)
	}
	return &obj
}

func expandEndpointLoggingSlice(in interface{}) *[]restapi.EndpointLogging {
	var out []restapi.EndpointLogging
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointLogging(v))
	}
	return &out
}

func flattenEndpointLoggingMutate(obj *restapi.EndpointLoggingMutate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["log_config_ids"] = obj.LogConfigIDs

	return []interface{}{m}
}

func flattenEndpointLoggingMutateSlice(objs *[]restapi.EndpointLoggingMutate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointLoggingMutate(&v))
	}
	return sl
}

func expandEndpointLoggingMutate(in interface{}) *restapi.EndpointLoggingMutate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointLoggingMutate
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["log_config_ids"]; ok {
		obj.LogConfigIDs = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointLoggingMutateSlice(in interface{}) *[]restapi.EndpointLoggingMutate {
	var out []restapi.EndpointLoggingMutate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointLoggingMutate(v))
	}
	return &out
}

func flattenEndpointRequestHeaders(obj *restapi.EndpointRequestHeaders) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["add"] = obj.Add
	m["remove"] = obj.Remove

	return []interface{}{m}
}

func flattenEndpointRequestHeadersSlice(objs *[]restapi.EndpointRequestHeaders) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointRequestHeaders(&v))
	}
	return sl
}

func expandEndpointRequestHeaders(in interface{}) *restapi.EndpointRequestHeaders {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointRequestHeaders
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["add"]; ok {
		obj.Add = *expandStringMap(v)
	}
	if v, ok := m["remove"]; ok {
		obj.Remove = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointRequestHeadersSlice(in interface{}) *[]restapi.EndpointRequestHeaders {
	var out []restapi.EndpointRequestHeaders
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointRequestHeaders(v))
	}
	return &out
}

func flattenEndpointResponseHeaders(obj *restapi.EndpointResponseHeaders) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["add"] = obj.Add
	m["remove"] = obj.Remove

	return []interface{}{m}
}

func flattenEndpointResponseHeadersSlice(objs *[]restapi.EndpointResponseHeaders) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointResponseHeaders(&v))
	}
	return sl
}

func expandEndpointResponseHeaders(in interface{}) *restapi.EndpointResponseHeaders {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointResponseHeaders
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["add"]; ok {
		obj.Add = *expandStringMap(v)
	}
	if v, ok := m["remove"]; ok {
		obj.Remove = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointResponseHeadersSlice(in interface{}) *[]restapi.EndpointResponseHeaders {
	var out []restapi.EndpointResponseHeaders
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointResponseHeaders(v))
	}
	return &out
}

func flattenEndpointIPPolicy(obj *restapi.EndpointIPPolicy) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["ip_policies"] = flattenRefSlice(&obj.IPPolicies)

	return []interface{}{m}
}

func flattenEndpointIPPolicySlice(objs *[]restapi.EndpointIPPolicy) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointIPPolicy(&v))
	}
	return sl
}

func expandEndpointIPPolicy(in interface{}) *restapi.EndpointIPPolicy {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointIPPolicy
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["ip_policies"]; ok {
		obj.IPPolicies = *expandRefSlice(v)
	}
	return &obj
}

func expandEndpointIPPolicySlice(in interface{}) *[]restapi.EndpointIPPolicy {
	var out []restapi.EndpointIPPolicy
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointIPPolicy(v))
	}
	return &out
}

func flattenEndpointIPPolicyMutate(obj *restapi.EndpointIPPolicyMutate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["ip_policy_ids"] = obj.IPPolicyIDs

	return []interface{}{m}
}

func flattenEndpointIPPolicyMutateSlice(objs *[]restapi.EndpointIPPolicyMutate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointIPPolicyMutate(&v))
	}
	return sl
}

func expandEndpointIPPolicyMutate(in interface{}) *restapi.EndpointIPPolicyMutate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointIPPolicyMutate
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["ip_policy_ids"]; ok {
		obj.IPPolicyIDs = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointIPPolicyMutateSlice(in interface{}) *[]restapi.EndpointIPPolicyMutate {
	var out []restapi.EndpointIPPolicyMutate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointIPPolicyMutate(v))
	}
	return &out
}

func flattenEndpointCircuitBreaker(obj *restapi.EndpointCircuitBreaker) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["tripped_duration"] = obj.TrippedDuration
	m["rolling_window"] = obj.RollingWindow
	m["num_buckets"] = obj.NumBuckets
	m["volume_threshold"] = obj.VolumeThreshold
	m["error_threshold_percentage"] = obj.ErrorThresholdPercentage

	return []interface{}{m}
}

func flattenEndpointCircuitBreakerSlice(objs *[]restapi.EndpointCircuitBreaker) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointCircuitBreaker(&v))
	}
	return sl
}

func expandEndpointCircuitBreaker(in interface{}) *restapi.EndpointCircuitBreaker {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointCircuitBreaker
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["tripped_duration"]; ok {
		obj.TrippedDuration = *expandUint32(v)
	}
	if v, ok := m["rolling_window"]; ok {
		obj.RollingWindow = *expandUint32(v)
	}
	if v, ok := m["num_buckets"]; ok {
		obj.NumBuckets = *expandUint32(v)
	}
	if v, ok := m["volume_threshold"]; ok {
		obj.VolumeThreshold = *expandUint32(v)
	}
	if v, ok := m["error_threshold_percentage"]; ok {
		obj.ErrorThresholdPercentage = *expandFloat64(v)
	}
	return &obj
}

func expandEndpointCircuitBreakerSlice(in interface{}) *[]restapi.EndpointCircuitBreaker {
	var out []restapi.EndpointCircuitBreaker
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointCircuitBreaker(v))
	}
	return &out
}

func flattenEndpointOAuth(obj *restapi.EndpointOAuth) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["provider"] = flattenEndpointOAuthProvider(&obj.Provider)
	m["options_passthrough"] = obj.OptionsPassthrough
	m["cookie_prefix"] = obj.CookiePrefix
	m["inactivity_timeout"] = obj.InactivityTimeout
	m["maximum_duration"] = obj.MaximumDuration
	m["auth_check_interval"] = obj.AuthCheckInterval

	return []interface{}{m}
}

func flattenEndpointOAuthSlice(objs *[]restapi.EndpointOAuth) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOAuth(&v))
	}
	return sl
}

func expandEndpointOAuth(in interface{}) *restapi.EndpointOAuth {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOAuth
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["provider"]; ok {
		obj.Provider = *expandEndpointOAuthProvider(v)
	}
	if v, ok := m["options_passthrough"]; ok {
		obj.OptionsPassthrough = *expandBool(v)
	}
	if v, ok := m["cookie_prefix"]; ok {
		obj.CookiePrefix = *expandString(v)
	}
	if v, ok := m["inactivity_timeout"]; ok {
		obj.InactivityTimeout = *expandUint32(v)
	}
	if v, ok := m["maximum_duration"]; ok {
		obj.MaximumDuration = *expandUint32(v)
	}
	if v, ok := m["auth_check_interval"]; ok {
		obj.AuthCheckInterval = *expandUint32(v)
	}
	return &obj
}

func expandEndpointOAuthSlice(in interface{}) *[]restapi.EndpointOAuth {
	var out []restapi.EndpointOAuth
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOAuth(v))
	}
	return &out
}

func flattenEndpointOAuthProvider(obj *restapi.EndpointOAuthProvider) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["github"] = flattenEndpointOAuthGitHub(obj.Github)
	m["facebook"] = flattenEndpointOAuthFacebook(obj.Facebook)
	m["microsoft"] = flattenEndpointOAuthMicrosoft(obj.Microsoft)
	m["google"] = flattenEndpointOAuthGoogle(obj.Google)

	return []interface{}{m}
}

func flattenEndpointOAuthProviderSlice(objs *[]restapi.EndpointOAuthProvider) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOAuthProvider(&v))
	}
	return sl
}

func expandEndpointOAuthProvider(in interface{}) *restapi.EndpointOAuthProvider {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOAuthProvider
	if v, ok := m["github"]; ok {
		obj.Github = expandEndpointOAuthGitHub(v)
	}
	if v, ok := m["facebook"]; ok {
		obj.Facebook = expandEndpointOAuthFacebook(v)
	}
	if v, ok := m["microsoft"]; ok {
		obj.Microsoft = expandEndpointOAuthMicrosoft(v)
	}
	if v, ok := m["google"]; ok {
		obj.Google = expandEndpointOAuthGoogle(v)
	}
	return &obj
}

func expandEndpointOAuthProviderSlice(in interface{}) *[]restapi.EndpointOAuthProvider {
	var out []restapi.EndpointOAuthProvider
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOAuthProvider(v))
	}
	return &out
}

func flattenEndpointOAuthGitHub(obj *restapi.EndpointOAuthGitHub) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["client_id"] = *obj.ClientID
	m["client_secret"] = *obj.ClientSecret
	m["scopes"] = obj.Scopes
	m["email_addresses"] = obj.EmailAddresses
	m["email_domains"] = obj.EmailDomains
	m["teams"] = obj.Teams
	m["organizations"] = obj.Organizations

	return []interface{}{m}
}

func flattenEndpointOAuthGitHubSlice(objs *[]restapi.EndpointOAuthGitHub) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOAuthGitHub(&v))
	}
	return sl
}

func expandEndpointOAuthGitHub(in interface{}) *restapi.EndpointOAuthGitHub {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOAuthGitHub
	if v, ok := m["client_id"]; ok {
		obj.ClientID = expandString(v)
	}
	if v, ok := m["client_secret"]; ok {
		obj.ClientSecret = expandString(v)
	}
	if v, ok := m["scopes"]; ok {
		obj.Scopes = *expandStringSlice(v)
	}
	if v, ok := m["email_addresses"]; ok {
		obj.EmailAddresses = *expandStringSlice(v)
	}
	if v, ok := m["email_domains"]; ok {
		obj.EmailDomains = *expandStringSlice(v)
	}
	if v, ok := m["teams"]; ok {
		obj.Teams = *expandStringSlice(v)
	}
	if v, ok := m["organizations"]; ok {
		obj.Organizations = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointOAuthGitHubSlice(in interface{}) *[]restapi.EndpointOAuthGitHub {
	var out []restapi.EndpointOAuthGitHub
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOAuthGitHub(v))
	}
	return &out
}

func flattenEndpointOAuthFacebook(obj *restapi.EndpointOAuthFacebook) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["client_id"] = *obj.ClientID
	m["client_secret"] = *obj.ClientSecret
	m["scopes"] = obj.Scopes
	m["email_addresses"] = obj.EmailAddresses
	m["email_domains"] = obj.EmailDomains

	return []interface{}{m}
}

func flattenEndpointOAuthFacebookSlice(objs *[]restapi.EndpointOAuthFacebook) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOAuthFacebook(&v))
	}
	return sl
}

func expandEndpointOAuthFacebook(in interface{}) *restapi.EndpointOAuthFacebook {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOAuthFacebook
	if v, ok := m["client_id"]; ok {
		obj.ClientID = expandString(v)
	}
	if v, ok := m["client_secret"]; ok {
		obj.ClientSecret = expandString(v)
	}
	if v, ok := m["scopes"]; ok {
		obj.Scopes = *expandStringSlice(v)
	}
	if v, ok := m["email_addresses"]; ok {
		obj.EmailAddresses = *expandStringSlice(v)
	}
	if v, ok := m["email_domains"]; ok {
		obj.EmailDomains = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointOAuthFacebookSlice(in interface{}) *[]restapi.EndpointOAuthFacebook {
	var out []restapi.EndpointOAuthFacebook
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOAuthFacebook(v))
	}
	return &out
}

func flattenEndpointOAuthMicrosoft(obj *restapi.EndpointOAuthMicrosoft) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["client_id"] = *obj.ClientID
	m["client_secret"] = *obj.ClientSecret
	m["scopes"] = obj.Scopes
	m["email_addresses"] = obj.EmailAddresses
	m["email_domains"] = obj.EmailDomains

	return []interface{}{m}
}

func flattenEndpointOAuthMicrosoftSlice(objs *[]restapi.EndpointOAuthMicrosoft) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOAuthMicrosoft(&v))
	}
	return sl
}

func expandEndpointOAuthMicrosoft(in interface{}) *restapi.EndpointOAuthMicrosoft {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOAuthMicrosoft
	if v, ok := m["client_id"]; ok {
		obj.ClientID = expandString(v)
	}
	if v, ok := m["client_secret"]; ok {
		obj.ClientSecret = expandString(v)
	}
	if v, ok := m["scopes"]; ok {
		obj.Scopes = *expandStringSlice(v)
	}
	if v, ok := m["email_addresses"]; ok {
		obj.EmailAddresses = *expandStringSlice(v)
	}
	if v, ok := m["email_domains"]; ok {
		obj.EmailDomains = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointOAuthMicrosoftSlice(in interface{}) *[]restapi.EndpointOAuthMicrosoft {
	var out []restapi.EndpointOAuthMicrosoft
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOAuthMicrosoft(v))
	}
	return &out
}

func flattenEndpointOAuthGoogle(obj *restapi.EndpointOAuthGoogle) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["client_id"] = *obj.ClientID
	m["client_secret"] = *obj.ClientSecret
	m["scopes"] = obj.Scopes
	m["email_addresses"] = obj.EmailAddresses
	m["email_domains"] = obj.EmailDomains

	return []interface{}{m}
}

func flattenEndpointOAuthGoogleSlice(objs *[]restapi.EndpointOAuthGoogle) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOAuthGoogle(&v))
	}
	return sl
}

func expandEndpointOAuthGoogle(in interface{}) *restapi.EndpointOAuthGoogle {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOAuthGoogle
	if v, ok := m["client_id"]; ok {
		obj.ClientID = expandString(v)
	}
	if v, ok := m["client_secret"]; ok {
		obj.ClientSecret = expandString(v)
	}
	if v, ok := m["scopes"]; ok {
		obj.Scopes = *expandStringSlice(v)
	}
	if v, ok := m["email_addresses"]; ok {
		obj.EmailAddresses = *expandStringSlice(v)
	}
	if v, ok := m["email_domains"]; ok {
		obj.EmailDomains = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointOAuthGoogleSlice(in interface{}) *[]restapi.EndpointOAuthGoogle {
	var out []restapi.EndpointOAuthGoogle
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOAuthGoogle(v))
	}
	return &out
}

func flattenEndpointSAML(obj *restapi.EndpointSAML) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["options_passthrough"] = obj.OptionsPassthrough
	m["cookie_prefix"] = obj.CookiePrefix
	m["inactivity_timeout"] = obj.InactivityTimeout
	m["maximum_duration"] = obj.MaximumDuration
	m["idp_metadata_url"] = obj.IdPMetadataURL
	m["idp_metadata"] = obj.IdPMetadata
	m["force_authn"] = obj.ForceAuthn
	m["allow_idp_initiated"] = *obj.AllowIdPInitiated
	m["authorized_groups"] = obj.AuthorizedGroups
	m["entity_id"] = obj.EntityID
	m["assertion_consumer_service_url"] = obj.AssertionConsumerServiceURL
	m["single_logout_url"] = obj.SingleLogoutURL
	m["request_signing_certificate_pem"] = obj.RequestSigningCertificatePEM
	m["metadata_url"] = obj.MetadataURL

	return []interface{}{m}
}

func flattenEndpointSAMLSlice(objs *[]restapi.EndpointSAML) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointSAML(&v))
	}
	return sl
}

func expandEndpointSAML(in interface{}) *restapi.EndpointSAML {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointSAML
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["options_passthrough"]; ok {
		obj.OptionsPassthrough = *expandBool(v)
	}
	if v, ok := m["cookie_prefix"]; ok {
		obj.CookiePrefix = *expandString(v)
	}
	if v, ok := m["inactivity_timeout"]; ok {
		obj.InactivityTimeout = *expandUint32(v)
	}
	if v, ok := m["maximum_duration"]; ok {
		obj.MaximumDuration = *expandUint32(v)
	}
	if v, ok := m["idp_metadata_url"]; ok {
		obj.IdPMetadataURL = *expandString(v)
	}
	if v, ok := m["idp_metadata"]; ok {
		obj.IdPMetadata = *expandString(v)
	}
	if v, ok := m["force_authn"]; ok {
		obj.ForceAuthn = *expandBool(v)
	}
	if v, ok := m["allow_idp_initiated"]; ok {
		obj.AllowIdPInitiated = expandBool(v)
	}
	if v, ok := m["authorized_groups"]; ok {
		obj.AuthorizedGroups = *expandStringSlice(v)
	}
	if v, ok := m["entity_id"]; ok {
		obj.EntityID = *expandString(v)
	}
	if v, ok := m["assertion_consumer_service_url"]; ok {
		obj.AssertionConsumerServiceURL = *expandString(v)
	}
	if v, ok := m["single_logout_url"]; ok {
		obj.SingleLogoutURL = *expandString(v)
	}
	if v, ok := m["request_signing_certificate_pem"]; ok {
		obj.RequestSigningCertificatePEM = *expandString(v)
	}
	if v, ok := m["metadata_url"]; ok {
		obj.MetadataURL = *expandString(v)
	}
	return &obj
}

func expandEndpointSAMLSlice(in interface{}) *[]restapi.EndpointSAML {
	var out []restapi.EndpointSAML
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointSAML(v))
	}
	return &out
}

func flattenEndpointSAMLMutate(obj *restapi.EndpointSAMLMutate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["options_passthrough"] = obj.OptionsPassthrough
	m["cookie_prefix"] = obj.CookiePrefix
	m["inactivity_timeout"] = obj.InactivityTimeout
	m["maximum_duration"] = obj.MaximumDuration
	m["idp_metadata_url"] = obj.IdPMetadataURL
	m["idp_metadata"] = obj.IdPMetadata
	m["force_authn"] = obj.ForceAuthn
	m["allow_idp_initiated"] = *obj.AllowIdPInitiated
	m["authorized_groups"] = obj.AuthorizedGroups

	return []interface{}{m}
}

func flattenEndpointSAMLMutateSlice(objs *[]restapi.EndpointSAMLMutate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointSAMLMutate(&v))
	}
	return sl
}

func expandEndpointSAMLMutate(in interface{}) *restapi.EndpointSAMLMutate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointSAMLMutate
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["options_passthrough"]; ok {
		obj.OptionsPassthrough = *expandBool(v)
	}
	if v, ok := m["cookie_prefix"]; ok {
		obj.CookiePrefix = *expandString(v)
	}
	if v, ok := m["inactivity_timeout"]; ok {
		obj.InactivityTimeout = *expandUint32(v)
	}
	if v, ok := m["maximum_duration"]; ok {
		obj.MaximumDuration = *expandUint32(v)
	}
	if v, ok := m["idp_metadata_url"]; ok {
		obj.IdPMetadataURL = *expandString(v)
	}
	if v, ok := m["idp_metadata"]; ok {
		obj.IdPMetadata = *expandString(v)
	}
	if v, ok := m["force_authn"]; ok {
		obj.ForceAuthn = *expandBool(v)
	}
	if v, ok := m["allow_idp_initiated"]; ok {
		obj.AllowIdPInitiated = expandBool(v)
	}
	if v, ok := m["authorized_groups"]; ok {
		obj.AuthorizedGroups = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointSAMLMutateSlice(in interface{}) *[]restapi.EndpointSAMLMutate {
	var out []restapi.EndpointSAMLMutate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointSAMLMutate(v))
	}
	return &out
}

func flattenEndpointOIDC(obj *restapi.EndpointOIDC) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["enabled"] = *obj.Enabled
	m["options_passthrough"] = obj.OptionsPassthrough
	m["cookie_prefix"] = obj.CookiePrefix
	m["inactivity_timeout"] = obj.InactivityTimeout
	m["maximum_duration"] = obj.MaximumDuration
	m["issuer"] = obj.Issuer
	m["client_id"] = obj.ClientID
	m["client_secret"] = obj.ClientSecret
	m["scopes"] = obj.Scopes

	return []interface{}{m}
}

func flattenEndpointOIDCSlice(objs *[]restapi.EndpointOIDC) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOIDC(&v))
	}
	return sl
}

func expandEndpointOIDC(in interface{}) *restapi.EndpointOIDC {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOIDC
	if v, ok := m["enabled"]; ok {
		obj.Enabled = expandBool(v)
	}
	if v, ok := m["options_passthrough"]; ok {
		obj.OptionsPassthrough = *expandBool(v)
	}
	if v, ok := m["cookie_prefix"]; ok {
		obj.CookiePrefix = *expandString(v)
	}
	if v, ok := m["inactivity_timeout"]; ok {
		obj.InactivityTimeout = *expandUint32(v)
	}
	if v, ok := m["maximum_duration"]; ok {
		obj.MaximumDuration = *expandUint32(v)
	}
	if v, ok := m["issuer"]; ok {
		obj.Issuer = *expandString(v)
	}
	if v, ok := m["client_id"]; ok {
		obj.ClientID = *expandString(v)
	}
	if v, ok := m["client_secret"]; ok {
		obj.ClientSecret = *expandString(v)
	}
	if v, ok := m["scopes"]; ok {
		obj.Scopes = *expandStringSlice(v)
	}
	return &obj
}

func expandEndpointOIDCSlice(in interface{}) *[]restapi.EndpointOIDC {
	var out []restapi.EndpointOIDC
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOIDC(v))
	}
	return &out
}

func flattenEndpointLoggingReplace(obj *restapi.EndpointLoggingReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointLoggingMutate(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointLoggingReplaceSlice(objs *[]restapi.EndpointLoggingReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointLoggingReplace(&v))
	}
	return sl
}

func expandEndpointLoggingReplace(in interface{}) *restapi.EndpointLoggingReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointLoggingReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointLoggingMutate(v)
	}
	return &obj
}

func expandEndpointLoggingReplaceSlice(in interface{}) *[]restapi.EndpointLoggingReplace {
	var out []restapi.EndpointLoggingReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointLoggingReplace(v))
	}
	return &out
}

func flattenEndpointBasicAuthReplace(obj *restapi.EndpointBasicAuthReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointBasicAuth(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointBasicAuthReplaceSlice(objs *[]restapi.EndpointBasicAuthReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointBasicAuthReplace(&v))
	}
	return sl
}

func expandEndpointBasicAuthReplace(in interface{}) *restapi.EndpointBasicAuthReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointBasicAuthReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointBasicAuth(v)
	}
	return &obj
}

func expandEndpointBasicAuthReplaceSlice(in interface{}) *[]restapi.EndpointBasicAuthReplace {
	var out []restapi.EndpointBasicAuthReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointBasicAuthReplace(v))
	}
	return &out
}

func flattenEndpointCircuitBreakerReplace(obj *restapi.EndpointCircuitBreakerReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointCircuitBreaker(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointCircuitBreakerReplaceSlice(objs *[]restapi.EndpointCircuitBreakerReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointCircuitBreakerReplace(&v))
	}
	return sl
}

func expandEndpointCircuitBreakerReplace(in interface{}) *restapi.EndpointCircuitBreakerReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointCircuitBreakerReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointCircuitBreaker(v)
	}
	return &obj
}

func expandEndpointCircuitBreakerReplaceSlice(in interface{}) *[]restapi.EndpointCircuitBreakerReplace {
	var out []restapi.EndpointCircuitBreakerReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointCircuitBreakerReplace(v))
	}
	return &out
}

func flattenEndpointCompressionReplace(obj *restapi.EndpointCompressionReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointCompression(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointCompressionReplaceSlice(objs *[]restapi.EndpointCompressionReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointCompressionReplace(&v))
	}
	return sl
}

func expandEndpointCompressionReplace(in interface{}) *restapi.EndpointCompressionReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointCompressionReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointCompression(v)
	}
	return &obj
}

func expandEndpointCompressionReplaceSlice(in interface{}) *[]restapi.EndpointCompressionReplace {
	var out []restapi.EndpointCompressionReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointCompressionReplace(v))
	}
	return &out
}

func flattenEndpointTLSTerminationReplace(obj *restapi.EndpointTLSTerminationReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointTLSTermination(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointTLSTerminationReplaceSlice(objs *[]restapi.EndpointTLSTerminationReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointTLSTerminationReplace(&v))
	}
	return sl
}

func expandEndpointTLSTerminationReplace(in interface{}) *restapi.EndpointTLSTerminationReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointTLSTerminationReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointTLSTermination(v)
	}
	return &obj
}

func expandEndpointTLSTerminationReplaceSlice(in interface{}) *[]restapi.EndpointTLSTerminationReplace {
	var out []restapi.EndpointTLSTerminationReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointTLSTerminationReplace(v))
	}
	return &out
}

func flattenEndpointIPPolicyReplace(obj *restapi.EndpointIPPolicyReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointIPPolicyMutate(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointIPPolicyReplaceSlice(objs *[]restapi.EndpointIPPolicyReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointIPPolicyReplace(&v))
	}
	return sl
}

func expandEndpointIPPolicyReplace(in interface{}) *restapi.EndpointIPPolicyReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointIPPolicyReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointIPPolicyMutate(v)
	}
	return &obj
}

func expandEndpointIPPolicyReplaceSlice(in interface{}) *[]restapi.EndpointIPPolicyReplace {
	var out []restapi.EndpointIPPolicyReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointIPPolicyReplace(v))
	}
	return &out
}

func flattenEndpointMutualTLSReplace(obj *restapi.EndpointMutualTLSReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointMutualTLSMutate(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointMutualTLSReplaceSlice(objs *[]restapi.EndpointMutualTLSReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointMutualTLSReplace(&v))
	}
	return sl
}

func expandEndpointMutualTLSReplace(in interface{}) *restapi.EndpointMutualTLSReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointMutualTLSReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointMutualTLSMutate(v)
	}
	return &obj
}

func expandEndpointMutualTLSReplaceSlice(in interface{}) *[]restapi.EndpointMutualTLSReplace {
	var out []restapi.EndpointMutualTLSReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointMutualTLSReplace(v))
	}
	return &out
}

func flattenEndpointRequestHeadersReplace(obj *restapi.EndpointRequestHeadersReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointRequestHeaders(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointRequestHeadersReplaceSlice(objs *[]restapi.EndpointRequestHeadersReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointRequestHeadersReplace(&v))
	}
	return sl
}

func expandEndpointRequestHeadersReplace(in interface{}) *restapi.EndpointRequestHeadersReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointRequestHeadersReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointRequestHeaders(v)
	}
	return &obj
}

func expandEndpointRequestHeadersReplaceSlice(in interface{}) *[]restapi.EndpointRequestHeadersReplace {
	var out []restapi.EndpointRequestHeadersReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointRequestHeadersReplace(v))
	}
	return &out
}

func flattenEndpointResponseHeadersReplace(obj *restapi.EndpointResponseHeadersReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointResponseHeaders(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointResponseHeadersReplaceSlice(objs *[]restapi.EndpointResponseHeadersReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointResponseHeadersReplace(&v))
	}
	return sl
}

func expandEndpointResponseHeadersReplace(in interface{}) *restapi.EndpointResponseHeadersReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointResponseHeadersReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointResponseHeaders(v)
	}
	return &obj
}

func expandEndpointResponseHeadersReplaceSlice(in interface{}) *[]restapi.EndpointResponseHeadersReplace {
	var out []restapi.EndpointResponseHeadersReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointResponseHeadersReplace(v))
	}
	return &out
}

func flattenEndpointOAuthReplace(obj *restapi.EndpointOAuthReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointOAuth(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointOAuthReplaceSlice(objs *[]restapi.EndpointOAuthReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOAuthReplace(&v))
	}
	return sl
}

func expandEndpointOAuthReplace(in interface{}) *restapi.EndpointOAuthReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOAuthReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointOAuth(v)
	}
	return &obj
}

func expandEndpointOAuthReplaceSlice(in interface{}) *[]restapi.EndpointOAuthReplace {
	var out []restapi.EndpointOAuthReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOAuthReplace(v))
	}
	return &out
}

func flattenEndpointWebhookValidationReplace(obj *restapi.EndpointWebhookValidationReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointWebhookValidation(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointWebhookValidationReplaceSlice(objs *[]restapi.EndpointWebhookValidationReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointWebhookValidationReplace(&v))
	}
	return sl
}

func expandEndpointWebhookValidationReplace(in interface{}) *restapi.EndpointWebhookValidationReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointWebhookValidationReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointWebhookValidation(v)
	}
	return &obj
}

func expandEndpointWebhookValidationReplaceSlice(in interface{}) *[]restapi.EndpointWebhookValidationReplace {
	var out []restapi.EndpointWebhookValidationReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointWebhookValidationReplace(v))
	}
	return &out
}

func flattenEndpointSAMLReplace(obj *restapi.EndpointSAMLReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointSAMLMutate(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointSAMLReplaceSlice(objs *[]restapi.EndpointSAMLReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointSAMLReplace(&v))
	}
	return sl
}

func expandEndpointSAMLReplace(in interface{}) *restapi.EndpointSAMLReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointSAMLReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointSAMLMutate(v)
	}
	return &obj
}

func expandEndpointSAMLReplaceSlice(in interface{}) *[]restapi.EndpointSAMLReplace {
	var out []restapi.EndpointSAMLReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointSAMLReplace(v))
	}
	return &out
}

func flattenEndpointOIDCReplace(obj *restapi.EndpointOIDCReplace) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["module"] = flattenEndpointOIDC(&obj.Module)

	return []interface{}{m}
}

func flattenEndpointOIDCReplaceSlice(objs *[]restapi.EndpointOIDCReplace) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenEndpointOIDCReplace(&v))
	}
	return sl
}

func expandEndpointOIDCReplace(in interface{}) *restapi.EndpointOIDCReplace {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.EndpointOIDCReplace
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["module"]; ok {
		obj.Module = *expandEndpointOIDC(v)
	}
	return &obj
}

func expandEndpointOIDCReplaceSlice(in interface{}) *[]restapi.EndpointOIDCReplace {
	var out []restapi.EndpointOIDCReplace
	for _, v := range in.([]interface{}) {
		out = append(out, *expandEndpointOIDCReplace(v))
	}
	return &out
}

func flattenReservedAddrCreate(obj *restapi.ReservedAddrCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["region"] = obj.Region
	m["endpoint_configuration_id"] = obj.EndpointConfigurationID

	return []interface{}{m}
}

func flattenReservedAddrCreateSlice(objs *[]restapi.ReservedAddrCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedAddrCreate(&v))
	}
	return sl
}

func expandReservedAddrCreate(in interface{}) *restapi.ReservedAddrCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedAddrCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["region"]; ok {
		obj.Region = *expandString(v)
	}
	if v, ok := m["endpoint_configuration_id"]; ok {
		obj.EndpointConfigurationID = *expandString(v)
	}
	return &obj
}

func expandReservedAddrCreateSlice(in interface{}) *[]restapi.ReservedAddrCreate {
	var out []restapi.ReservedAddrCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedAddrCreate(v))
	}
	return &out
}

func flattenReservedAddrUpdate(obj *restapi.ReservedAddrUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata
	m["endpoint_configuration_id"] = *obj.EndpointConfigurationID

	return []interface{}{m}
}

func flattenReservedAddrUpdateSlice(objs *[]restapi.ReservedAddrUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedAddrUpdate(&v))
	}
	return sl
}

func expandReservedAddrUpdate(in interface{}) *restapi.ReservedAddrUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedAddrUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["endpoint_configuration_id"]; ok {
		obj.EndpointConfigurationID = expandString(v)
	}
	return &obj
}

func expandReservedAddrUpdateSlice(in interface{}) *[]restapi.ReservedAddrUpdate {
	var out []restapi.ReservedAddrUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedAddrUpdate(v))
	}
	return &out
}

func flattenReservedAddr(obj *restapi.ReservedAddr) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["addr"] = obj.Addr
	m["region"] = obj.Region
	m["endpoint_configuration"] = flattenRef(obj.EndpointConfiguration)

	return []interface{}{m}
}

func flattenReservedAddrSlice(objs *[]restapi.ReservedAddr) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedAddr(&v))
	}
	return sl
}

func expandReservedAddr(in interface{}) *restapi.ReservedAddr {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedAddr
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["addr"]; ok {
		obj.Addr = *expandString(v)
	}
	if v, ok := m["region"]; ok {
		obj.Region = *expandString(v)
	}
	if v, ok := m["endpoint_configuration"]; ok {
		obj.EndpointConfiguration = expandRef(v)
	}
	return &obj
}

func expandReservedAddrSlice(in interface{}) *[]restapi.ReservedAddr {
	var out []restapi.ReservedAddr
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedAddr(v))
	}
	return &out
}

func flattenReservedAddrList(obj *restapi.ReservedAddrList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["reserved_addrs"] = flattenReservedAddrSlice(&obj.ReservedAddrs)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenReservedAddrListSlice(objs *[]restapi.ReservedAddrList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedAddrList(&v))
	}
	return sl
}

func expandReservedAddrList(in interface{}) *restapi.ReservedAddrList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedAddrList
	if v, ok := m["reserved_addrs"]; ok {
		obj.ReservedAddrs = *expandReservedAddrSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandReservedAddrListSlice(in interface{}) *[]restapi.ReservedAddrList {
	var out []restapi.ReservedAddrList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedAddrList(v))
	}
	return &out
}

func flattenReservedDomainCreate(obj *restapi.ReservedDomainCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["name"] = obj.Name
	m["region"] = obj.Region
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["http_endpoint_configuration_id"] = obj.HTTPEndpointConfigurationID
	m["https_endpoint_configuration_id"] = obj.HTTPSEndpointConfigurationID
	m["certificate_id"] = *obj.CertificateID
	m["certificate_management_policy"] = flattenReservedDomainCertPolicy(obj.CertificateManagementPolicy)

	return []interface{}{m}
}

func flattenReservedDomainCreateSlice(objs *[]restapi.ReservedDomainCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedDomainCreate(&v))
	}
	return sl
}

func expandReservedDomainCreate(in interface{}) *restapi.ReservedDomainCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedDomainCreate
	if v, ok := m["name"]; ok {
		obj.Name = *expandString(v)
	}
	if v, ok := m["region"]; ok {
		obj.Region = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["http_endpoint_configuration_id"]; ok {
		obj.HTTPEndpointConfigurationID = *expandString(v)
	}
	if v, ok := m["https_endpoint_configuration_id"]; ok {
		obj.HTTPSEndpointConfigurationID = *expandString(v)
	}
	if v, ok := m["certificate_id"]; ok {
		obj.CertificateID = expandString(v)
	}
	if v, ok := m["certificate_management_policy"]; ok {
		obj.CertificateManagementPolicy = expandReservedDomainCertPolicy(v)
	}
	return &obj
}

func expandReservedDomainCreateSlice(in interface{}) *[]restapi.ReservedDomainCreate {
	var out []restapi.ReservedDomainCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedDomainCreate(v))
	}
	return &out
}

func flattenReservedDomainUpdate(obj *restapi.ReservedDomainUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata
	m["http_endpoint_configuration_id"] = *obj.HTTPEndpointConfigurationID
	m["https_endpoint_configuration_id"] = *obj.HTTPSEndpointConfigurationID
	m["certificate_id"] = *obj.CertificateID
	m["certificate_management_policy"] = flattenReservedDomainCertPolicy(obj.CertificateManagementPolicy)

	return []interface{}{m}
}

func flattenReservedDomainUpdateSlice(objs *[]restapi.ReservedDomainUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedDomainUpdate(&v))
	}
	return sl
}

func expandReservedDomainUpdate(in interface{}) *restapi.ReservedDomainUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedDomainUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["http_endpoint_configuration_id"]; ok {
		obj.HTTPEndpointConfigurationID = expandString(v)
	}
	if v, ok := m["https_endpoint_configuration_id"]; ok {
		obj.HTTPSEndpointConfigurationID = expandString(v)
	}
	if v, ok := m["certificate_id"]; ok {
		obj.CertificateID = expandString(v)
	}
	if v, ok := m["certificate_management_policy"]; ok {
		obj.CertificateManagementPolicy = expandReservedDomainCertPolicy(v)
	}
	return &obj
}

func expandReservedDomainUpdateSlice(in interface{}) *[]restapi.ReservedDomainUpdate {
	var out []restapi.ReservedDomainUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedDomainUpdate(v))
	}
	return &out
}

func flattenReservedDomain(obj *restapi.ReservedDomain) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["domain"] = obj.Domain
	m["region"] = obj.Region
	m["cname_target"] = *obj.CNAMETarget
	m["http_endpoint_configuration"] = flattenRef(obj.HTTPEndpointConfiguration)
	m["https_endpoint_configuration"] = flattenRef(obj.HTTPSEndpointConfiguration)
	m["certificate"] = flattenRef(obj.Certificate)
	m["certificate_management_policy"] = flattenReservedDomainCertPolicy(obj.CertificateManagementPolicy)
	m["certificate_management_status"] = flattenReservedDomainCertStatus(obj.CertificateManagementStatus)

	return []interface{}{m}
}

func flattenReservedDomainSlice(objs *[]restapi.ReservedDomain) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedDomain(&v))
	}
	return sl
}

func expandReservedDomain(in interface{}) *restapi.ReservedDomain {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedDomain
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["domain"]; ok {
		obj.Domain = *expandString(v)
	}
	if v, ok := m["region"]; ok {
		obj.Region = *expandString(v)
	}
	if v, ok := m["cname_target"]; ok {
		obj.CNAMETarget = expandString(v)
	}
	if v, ok := m["http_endpoint_configuration"]; ok {
		obj.HTTPEndpointConfiguration = expandRef(v)
	}
	if v, ok := m["https_endpoint_configuration"]; ok {
		obj.HTTPSEndpointConfiguration = expandRef(v)
	}
	if v, ok := m["certificate"]; ok {
		obj.Certificate = expandRef(v)
	}
	if v, ok := m["certificate_management_policy"]; ok {
		obj.CertificateManagementPolicy = expandReservedDomainCertPolicy(v)
	}
	if v, ok := m["certificate_management_status"]; ok {
		obj.CertificateManagementStatus = expandReservedDomainCertStatus(v)
	}
	return &obj
}

func expandReservedDomainSlice(in interface{}) *[]restapi.ReservedDomain {
	var out []restapi.ReservedDomain
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedDomain(v))
	}
	return &out
}

func flattenReservedDomainList(obj *restapi.ReservedDomainList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["reserved_domains"] = flattenReservedDomainSlice(&obj.ReservedDomains)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenReservedDomainListSlice(objs *[]restapi.ReservedDomainList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedDomainList(&v))
	}
	return sl
}

func expandReservedDomainList(in interface{}) *restapi.ReservedDomainList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedDomainList
	if v, ok := m["reserved_domains"]; ok {
		obj.ReservedDomains = *expandReservedDomainSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandReservedDomainListSlice(in interface{}) *[]restapi.ReservedDomainList {
	var out []restapi.ReservedDomainList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedDomainList(v))
	}
	return &out
}

func flattenReservedDomainCertPolicy(obj *restapi.ReservedDomainCertPolicy) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["authority"] = obj.Authority
	m["private_key_type"] = obj.PrivateKeyType

	return []interface{}{m}
}

func flattenReservedDomainCertPolicySlice(objs *[]restapi.ReservedDomainCertPolicy) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedDomainCertPolicy(&v))
	}
	return sl
}

func expandReservedDomainCertPolicy(in interface{}) *restapi.ReservedDomainCertPolicy {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedDomainCertPolicy
	if v, ok := m["authority"]; ok {
		obj.Authority = *expandString(v)
	}
	if v, ok := m["private_key_type"]; ok {
		obj.PrivateKeyType = *expandString(v)
	}
	return &obj
}

func expandReservedDomainCertPolicySlice(in interface{}) *[]restapi.ReservedDomainCertPolicy {
	var out []restapi.ReservedDomainCertPolicy
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedDomainCertPolicy(v))
	}
	return &out
}

func flattenReservedDomainCertStatus(obj *restapi.ReservedDomainCertStatus) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["renews_at"] = *obj.RenewsAt
	m["provisioning_job"] = flattenReservedDomainCertJob(obj.ProvisioningJob)

	return []interface{}{m}
}

func flattenReservedDomainCertStatusSlice(objs *[]restapi.ReservedDomainCertStatus) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedDomainCertStatus(&v))
	}
	return sl
}

func expandReservedDomainCertStatus(in interface{}) *restapi.ReservedDomainCertStatus {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedDomainCertStatus
	if v, ok := m["renews_at"]; ok {
		obj.RenewsAt = expandString(v)
	}
	if v, ok := m["provisioning_job"]; ok {
		obj.ProvisioningJob = expandReservedDomainCertJob(v)
	}
	return &obj
}

func expandReservedDomainCertStatusSlice(in interface{}) *[]restapi.ReservedDomainCertStatus {
	var out []restapi.ReservedDomainCertStatus
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedDomainCertStatus(v))
	}
	return &out
}

func flattenReservedDomainCertNSTarget(obj *restapi.ReservedDomainCertNSTarget) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["zone"] = obj.Zone
	m["nameservers"] = obj.Nameservers

	return []interface{}{m}
}

func flattenReservedDomainCertNSTargetSlice(objs *[]restapi.ReservedDomainCertNSTarget) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedDomainCertNSTarget(&v))
	}
	return sl
}

func expandReservedDomainCertNSTarget(in interface{}) *restapi.ReservedDomainCertNSTarget {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedDomainCertNSTarget
	if v, ok := m["zone"]; ok {
		obj.Zone = *expandString(v)
	}
	if v, ok := m["nameservers"]; ok {
		obj.Nameservers = *expandStringSlice(v)
	}
	return &obj
}

func expandReservedDomainCertNSTargetSlice(in interface{}) *[]restapi.ReservedDomainCertNSTarget {
	var out []restapi.ReservedDomainCertNSTarget
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedDomainCertNSTarget(v))
	}
	return &out
}

func flattenReservedDomainCertJob(obj *restapi.ReservedDomainCertJob) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["error_code"] = *obj.ErrorCode
	m["msg"] = obj.Msg
	m["started_at"] = obj.StartedAt
	m["retries_at"] = *obj.RetriesAt
	m["ns_targets"] = flattenReservedDomainCertNSTargetSlice(&obj.NSTargets)

	return []interface{}{m}
}

func flattenReservedDomainCertJobSlice(objs *[]restapi.ReservedDomainCertJob) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenReservedDomainCertJob(&v))
	}
	return sl
}

func expandReservedDomainCertJob(in interface{}) *restapi.ReservedDomainCertJob {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.ReservedDomainCertJob
	if v, ok := m["error_code"]; ok {
		obj.ErrorCode = expandString(v)
	}
	if v, ok := m["msg"]; ok {
		obj.Msg = *expandString(v)
	}
	if v, ok := m["started_at"]; ok {
		obj.StartedAt = *expandString(v)
	}
	if v, ok := m["retries_at"]; ok {
		obj.RetriesAt = expandString(v)
	}
	if v, ok := m["ns_targets"]; ok {
		obj.NSTargets = *expandReservedDomainCertNSTargetSlice(v)
	}
	return &obj
}

func expandReservedDomainCertJobSlice(in interface{}) *[]restapi.ReservedDomainCertJob {
	var out []restapi.ReservedDomainCertJob
	for _, v := range in.([]interface{}) {
		out = append(out, *expandReservedDomainCertJob(v))
	}
	return &out
}

func flattenRootResponse(obj *restapi.RootResponse) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["uri"] = obj.URI
	m["subresource_uris"] = obj.SubresourceURIs

	return []interface{}{m}
}

func flattenRootResponseSlice(objs *[]restapi.RootResponse) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenRootResponse(&v))
	}
	return sl
}

func expandRootResponse(in interface{}) *restapi.RootResponse {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.RootResponse
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["subresource_uris"]; ok {
		obj.SubresourceURIs = *expandStringMap(v)
	}
	return &obj
}

func expandRootResponseSlice(in interface{}) *[]restapi.RootResponse {
	var out []restapi.RootResponse
	for _, v := range in.([]interface{}) {
		out = append(out, *expandRootResponse(v))
	}
	return &out
}

func flattenSSHCertificateAuthorityCreate(obj *restapi.SSHCertificateAuthorityCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["private_key_type"] = obj.PrivateKeyType
	m["elliptic_curve"] = obj.EllipticCurve
	m["key_size"] = obj.KeySize

	return []interface{}{m}
}

func flattenSSHCertificateAuthorityCreateSlice(objs *[]restapi.SSHCertificateAuthorityCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHCertificateAuthorityCreate(&v))
	}
	return sl
}

func expandSSHCertificateAuthorityCreate(in interface{}) *restapi.SSHCertificateAuthorityCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHCertificateAuthorityCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["private_key_type"]; ok {
		obj.PrivateKeyType = *expandString(v)
	}
	if v, ok := m["elliptic_curve"]; ok {
		obj.EllipticCurve = *expandString(v)
	}
	if v, ok := m["key_size"]; ok {
		obj.KeySize = *expandInt64(v)
	}
	return &obj
}

func expandSSHCertificateAuthorityCreateSlice(in interface{}) *[]restapi.SSHCertificateAuthorityCreate {
	var out []restapi.SSHCertificateAuthorityCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHCertificateAuthorityCreate(v))
	}
	return &out
}

func flattenSSHCertificateAuthorityUpdate(obj *restapi.SSHCertificateAuthorityUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata

	return []interface{}{m}
}

func flattenSSHCertificateAuthorityUpdateSlice(objs *[]restapi.SSHCertificateAuthorityUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHCertificateAuthorityUpdate(&v))
	}
	return sl
}

func expandSSHCertificateAuthorityUpdate(in interface{}) *restapi.SSHCertificateAuthorityUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHCertificateAuthorityUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	return &obj
}

func expandSSHCertificateAuthorityUpdateSlice(in interface{}) *[]restapi.SSHCertificateAuthorityUpdate {
	var out []restapi.SSHCertificateAuthorityUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHCertificateAuthorityUpdate(v))
	}
	return &out
}

func flattenSSHCertificateAuthority(obj *restapi.SSHCertificateAuthority) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["public_key"] = obj.PublicKey
	m["key_type"] = obj.KeyType

	return []interface{}{m}
}

func flattenSSHCertificateAuthoritySlice(objs *[]restapi.SSHCertificateAuthority) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHCertificateAuthority(&v))
	}
	return sl
}

func expandSSHCertificateAuthority(in interface{}) *restapi.SSHCertificateAuthority {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHCertificateAuthority
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["public_key"]; ok {
		obj.PublicKey = *expandString(v)
	}
	if v, ok := m["key_type"]; ok {
		obj.KeyType = *expandString(v)
	}
	return &obj
}

func expandSSHCertificateAuthoritySlice(in interface{}) *[]restapi.SSHCertificateAuthority {
	var out []restapi.SSHCertificateAuthority
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHCertificateAuthority(v))
	}
	return &out
}

func flattenSSHCertificateAuthorityList(obj *restapi.SSHCertificateAuthorityList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ssh_certificate_authorities"] = flattenSSHCertificateAuthoritySlice(&obj.SSHCertificateAuthorities)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenSSHCertificateAuthorityListSlice(objs *[]restapi.SSHCertificateAuthorityList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHCertificateAuthorityList(&v))
	}
	return sl
}

func expandSSHCertificateAuthorityList(in interface{}) *restapi.SSHCertificateAuthorityList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHCertificateAuthorityList
	if v, ok := m["ssh_certificate_authorities"]; ok {
		obj.SSHCertificateAuthorities = *expandSSHCertificateAuthoritySlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandSSHCertificateAuthorityListSlice(in interface{}) *[]restapi.SSHCertificateAuthorityList {
	var out []restapi.SSHCertificateAuthorityList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHCertificateAuthorityList(v))
	}
	return &out
}

func flattenSSHCredentialCreate(obj *restapi.SSHCredentialCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["acl"] = obj.ACL
	m["public_key"] = obj.PublicKey

	return []interface{}{m}
}

func flattenSSHCredentialCreateSlice(objs *[]restapi.SSHCredentialCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHCredentialCreate(&v))
	}
	return sl
}

func expandSSHCredentialCreate(in interface{}) *restapi.SSHCredentialCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHCredentialCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["acl"]; ok {
		obj.ACL = *expandStringSlice(v)
	}
	if v, ok := m["public_key"]; ok {
		obj.PublicKey = *expandString(v)
	}
	return &obj
}

func expandSSHCredentialCreateSlice(in interface{}) *[]restapi.SSHCredentialCreate {
	var out []restapi.SSHCredentialCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHCredentialCreate(v))
	}
	return &out
}

func flattenSSHCredentialUpdate(obj *restapi.SSHCredentialUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata
	m["acl"] = *obj.ACL

	return []interface{}{m}
}

func flattenSSHCredentialUpdateSlice(objs *[]restapi.SSHCredentialUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHCredentialUpdate(&v))
	}
	return sl
}

func expandSSHCredentialUpdate(in interface{}) *restapi.SSHCredentialUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHCredentialUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	if v, ok := m["acl"]; ok {
		obj.ACL = expandStringSlice(v)
	}
	return &obj
}

func expandSSHCredentialUpdateSlice(in interface{}) *[]restapi.SSHCredentialUpdate {
	var out []restapi.SSHCredentialUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHCredentialUpdate(v))
	}
	return &out
}

func flattenSSHCredential(obj *restapi.SSHCredential) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["public_key"] = obj.PublicKey
	m["acl"] = obj.ACL

	return []interface{}{m}
}

func flattenSSHCredentialSlice(objs *[]restapi.SSHCredential) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHCredential(&v))
	}
	return sl
}

func expandSSHCredential(in interface{}) *restapi.SSHCredential {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHCredential
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["public_key"]; ok {
		obj.PublicKey = *expandString(v)
	}
	if v, ok := m["acl"]; ok {
		obj.ACL = *expandStringSlice(v)
	}
	return &obj
}

func expandSSHCredentialSlice(in interface{}) *[]restapi.SSHCredential {
	var out []restapi.SSHCredential
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHCredential(v))
	}
	return &out
}

func flattenSSHCredentialList(obj *restapi.SSHCredentialList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ssh_credentials"] = flattenSSHCredentialSlice(&obj.SSHCredentials)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenSSHCredentialListSlice(objs *[]restapi.SSHCredentialList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHCredentialList(&v))
	}
	return sl
}

func expandSSHCredentialList(in interface{}) *restapi.SSHCredentialList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHCredentialList
	if v, ok := m["ssh_credentials"]; ok {
		obj.SSHCredentials = *expandSSHCredentialSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandSSHCredentialListSlice(in interface{}) *[]restapi.SSHCredentialList {
	var out []restapi.SSHCredentialList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHCredentialList(v))
	}
	return &out
}

func flattenSSHHostCertificateCreate(obj *restapi.SSHHostCertificateCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ssh_certificate_authority_id"] = obj.SSHCertificateAuthorityID
	m["public_key"] = obj.PublicKey
	m["principals"] = obj.Principals
	m["valid_after"] = obj.ValidAfter
	m["valid_until"] = obj.ValidUntil
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata

	return []interface{}{m}
}

func flattenSSHHostCertificateCreateSlice(objs *[]restapi.SSHHostCertificateCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHHostCertificateCreate(&v))
	}
	return sl
}

func expandSSHHostCertificateCreate(in interface{}) *restapi.SSHHostCertificateCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHHostCertificateCreate
	if v, ok := m["ssh_certificate_authority_id"]; ok {
		obj.SSHCertificateAuthorityID = *expandString(v)
	}
	if v, ok := m["public_key"]; ok {
		obj.PublicKey = *expandString(v)
	}
	if v, ok := m["principals"]; ok {
		obj.Principals = *expandStringSlice(v)
	}
	if v, ok := m["valid_after"]; ok {
		obj.ValidAfter = *expandString(v)
	}
	if v, ok := m["valid_until"]; ok {
		obj.ValidUntil = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	return &obj
}

func expandSSHHostCertificateCreateSlice(in interface{}) *[]restapi.SSHHostCertificateCreate {
	var out []restapi.SSHHostCertificateCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHHostCertificateCreate(v))
	}
	return &out
}

func flattenSSHHostCertificateUpdate(obj *restapi.SSHHostCertificateUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata

	return []interface{}{m}
}

func flattenSSHHostCertificateUpdateSlice(objs *[]restapi.SSHHostCertificateUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHHostCertificateUpdate(&v))
	}
	return sl
}

func expandSSHHostCertificateUpdate(in interface{}) *restapi.SSHHostCertificateUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHHostCertificateUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	return &obj
}

func expandSSHHostCertificateUpdateSlice(in interface{}) *[]restapi.SSHHostCertificateUpdate {
	var out []restapi.SSHHostCertificateUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHHostCertificateUpdate(v))
	}
	return &out
}

func flattenSSHHostCertificate(obj *restapi.SSHHostCertificate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["public_key"] = obj.PublicKey
	m["key_type"] = obj.KeyType
	m["ssh_certificate_authority_id"] = obj.SSHCertificateAuthorityID
	m["principals"] = obj.Principals
	m["valid_after"] = obj.ValidAfter
	m["valid_until"] = obj.ValidUntil
	m["certificate"] = obj.Certificate

	return []interface{}{m}
}

func flattenSSHHostCertificateSlice(objs *[]restapi.SSHHostCertificate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHHostCertificate(&v))
	}
	return sl
}

func expandSSHHostCertificate(in interface{}) *restapi.SSHHostCertificate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHHostCertificate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["public_key"]; ok {
		obj.PublicKey = *expandString(v)
	}
	if v, ok := m["key_type"]; ok {
		obj.KeyType = *expandString(v)
	}
	if v, ok := m["ssh_certificate_authority_id"]; ok {
		obj.SSHCertificateAuthorityID = *expandString(v)
	}
	if v, ok := m["principals"]; ok {
		obj.Principals = *expandStringSlice(v)
	}
	if v, ok := m["valid_after"]; ok {
		obj.ValidAfter = *expandString(v)
	}
	if v, ok := m["valid_until"]; ok {
		obj.ValidUntil = *expandString(v)
	}
	if v, ok := m["certificate"]; ok {
		obj.Certificate = *expandString(v)
	}
	return &obj
}

func expandSSHHostCertificateSlice(in interface{}) *[]restapi.SSHHostCertificate {
	var out []restapi.SSHHostCertificate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHHostCertificate(v))
	}
	return &out
}

func flattenSSHHostCertificateList(obj *restapi.SSHHostCertificateList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ssh_host_certificates"] = flattenSSHHostCertificateSlice(&obj.SSHHostCertificates)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenSSHHostCertificateListSlice(objs *[]restapi.SSHHostCertificateList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHHostCertificateList(&v))
	}
	return sl
}

func expandSSHHostCertificateList(in interface{}) *restapi.SSHHostCertificateList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHHostCertificateList
	if v, ok := m["ssh_host_certificates"]; ok {
		obj.SSHHostCertificates = *expandSSHHostCertificateSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandSSHHostCertificateListSlice(in interface{}) *[]restapi.SSHHostCertificateList {
	var out []restapi.SSHHostCertificateList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHHostCertificateList(v))
	}
	return &out
}

func flattenSSHUserCertificateCreate(obj *restapi.SSHUserCertificateCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ssh_certificate_authority_id"] = obj.SSHCertificateAuthorityID
	m["public_key"] = obj.PublicKey
	m["principals"] = obj.Principals
	m["critical_options"] = obj.CriticalOptions
	m["extensions"] = obj.Extensions
	m["valid_after"] = obj.ValidAfter
	m["valid_until"] = obj.ValidUntil
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata

	return []interface{}{m}
}

func flattenSSHUserCertificateCreateSlice(objs *[]restapi.SSHUserCertificateCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHUserCertificateCreate(&v))
	}
	return sl
}

func expandSSHUserCertificateCreate(in interface{}) *restapi.SSHUserCertificateCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHUserCertificateCreate
	if v, ok := m["ssh_certificate_authority_id"]; ok {
		obj.SSHCertificateAuthorityID = *expandString(v)
	}
	if v, ok := m["public_key"]; ok {
		obj.PublicKey = *expandString(v)
	}
	if v, ok := m["principals"]; ok {
		obj.Principals = *expandStringSlice(v)
	}
	if v, ok := m["critical_options"]; ok {
		obj.CriticalOptions = *expandStringMap(v)
	}
	if v, ok := m["extensions"]; ok {
		obj.Extensions = *expandStringMap(v)
	}
	if v, ok := m["valid_after"]; ok {
		obj.ValidAfter = *expandString(v)
	}
	if v, ok := m["valid_until"]; ok {
		obj.ValidUntil = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	return &obj
}

func expandSSHUserCertificateCreateSlice(in interface{}) *[]restapi.SSHUserCertificateCreate {
	var out []restapi.SSHUserCertificateCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHUserCertificateCreate(v))
	}
	return &out
}

func flattenSSHUserCertificateUpdate(obj *restapi.SSHUserCertificateUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata

	return []interface{}{m}
}

func flattenSSHUserCertificateUpdateSlice(objs *[]restapi.SSHUserCertificateUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHUserCertificateUpdate(&v))
	}
	return sl
}

func expandSSHUserCertificateUpdate(in interface{}) *restapi.SSHUserCertificateUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHUserCertificateUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	return &obj
}

func expandSSHUserCertificateUpdateSlice(in interface{}) *[]restapi.SSHUserCertificateUpdate {
	var out []restapi.SSHUserCertificateUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHUserCertificateUpdate(v))
	}
	return &out
}

func flattenSSHUserCertificate(obj *restapi.SSHUserCertificate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["public_key"] = obj.PublicKey
	m["key_type"] = obj.KeyType
	m["ssh_certificate_authority_id"] = obj.SSHCertificateAuthorityID
	m["principals"] = obj.Principals
	m["critical_options"] = obj.CriticalOptions
	m["extensions"] = obj.Extensions
	m["valid_after"] = obj.ValidAfter
	m["valid_until"] = obj.ValidUntil
	m["certificate"] = obj.Certificate

	return []interface{}{m}
}

func flattenSSHUserCertificateSlice(objs *[]restapi.SSHUserCertificate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHUserCertificate(&v))
	}
	return sl
}

func expandSSHUserCertificate(in interface{}) *restapi.SSHUserCertificate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHUserCertificate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["public_key"]; ok {
		obj.PublicKey = *expandString(v)
	}
	if v, ok := m["key_type"]; ok {
		obj.KeyType = *expandString(v)
	}
	if v, ok := m["ssh_certificate_authority_id"]; ok {
		obj.SSHCertificateAuthorityID = *expandString(v)
	}
	if v, ok := m["principals"]; ok {
		obj.Principals = *expandStringSlice(v)
	}
	if v, ok := m["critical_options"]; ok {
		obj.CriticalOptions = *expandStringMap(v)
	}
	if v, ok := m["extensions"]; ok {
		obj.Extensions = *expandStringMap(v)
	}
	if v, ok := m["valid_after"]; ok {
		obj.ValidAfter = *expandString(v)
	}
	if v, ok := m["valid_until"]; ok {
		obj.ValidUntil = *expandString(v)
	}
	if v, ok := m["certificate"]; ok {
		obj.Certificate = *expandString(v)
	}
	return &obj
}

func expandSSHUserCertificateSlice(in interface{}) *[]restapi.SSHUserCertificate {
	var out []restapi.SSHUserCertificate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHUserCertificate(v))
	}
	return &out
}

func flattenSSHUserCertificateList(obj *restapi.SSHUserCertificateList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ssh_user_certificates"] = flattenSSHUserCertificateSlice(&obj.SSHUserCertificates)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenSSHUserCertificateListSlice(objs *[]restapi.SSHUserCertificateList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenSSHUserCertificateList(&v))
	}
	return sl
}

func expandSSHUserCertificateList(in interface{}) *restapi.SSHUserCertificateList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.SSHUserCertificateList
	if v, ok := m["ssh_user_certificates"]; ok {
		obj.SSHUserCertificates = *expandSSHUserCertificateSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandSSHUserCertificateListSlice(in interface{}) *[]restapi.SSHUserCertificateList {
	var out []restapi.SSHUserCertificateList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandSSHUserCertificateList(v))
	}
	return &out
}

func flattenTLSCertificateCreate(obj *restapi.TLSCertificateCreate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["certificate_pem"] = obj.CertificatePEM
	m["private_key_pem"] = obj.PrivateKeyPEM

	return []interface{}{m}
}

func flattenTLSCertificateCreateSlice(objs *[]restapi.TLSCertificateCreate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTLSCertificateCreate(&v))
	}
	return sl
}

func expandTLSCertificateCreate(in interface{}) *restapi.TLSCertificateCreate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TLSCertificateCreate
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["certificate_pem"]; ok {
		obj.CertificatePEM = *expandString(v)
	}
	if v, ok := m["private_key_pem"]; ok {
		obj.PrivateKeyPEM = *expandString(v)
	}
	return &obj
}

func expandTLSCertificateCreateSlice(in interface{}) *[]restapi.TLSCertificateCreate {
	var out []restapi.TLSCertificateCreate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTLSCertificateCreate(v))
	}
	return &out
}

func flattenTLSCertificateUpdate(obj *restapi.TLSCertificateUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["description"] = *obj.Description
	m["metadata"] = *obj.Metadata

	return []interface{}{m}
}

func flattenTLSCertificateUpdateSlice(objs *[]restapi.TLSCertificateUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTLSCertificateUpdate(&v))
	}
	return sl
}

func expandTLSCertificateUpdate(in interface{}) *restapi.TLSCertificateUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TLSCertificateUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = expandString(v)
	}
	return &obj
}

func expandTLSCertificateUpdateSlice(in interface{}) *[]restapi.TLSCertificateUpdate {
	var out []restapi.TLSCertificateUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTLSCertificateUpdate(v))
	}
	return &out
}

func flattenTLSCertificate(obj *restapi.TLSCertificate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["uri"] = obj.URI
	m["created_at"] = obj.CreatedAt
	m["description"] = obj.Description
	m["metadata"] = obj.Metadata
	m["certificate_pem"] = obj.CertificatePEM
	m["subject_common_name"] = obj.SubjectCommonName
	m["subject_alternative_names"] = flattenTLSCertificateSANs(&obj.SubjectAlternativeNames)
	m["issued_at"] = *obj.IssuedAt
	m["not_before"] = obj.NotBefore
	m["not_after"] = obj.NotAfter
	m["key_usages"] = obj.KeyUsages
	m["extended_key_usages"] = obj.ExtendedKeyUsages
	m["private_key_type"] = obj.PrivateKeyType
	m["issuer_common_name"] = obj.IssuerCommonName
	m["serial_number"] = obj.SerialNumber
	m["subject_organization"] = obj.SubjectOrganization
	m["subject_organizational_unit"] = obj.SubjectOrganizationalUnit
	m["subject_locality"] = obj.SubjectLocality
	m["subject_province"] = obj.SubjectProvince
	m["subject_country"] = obj.SubjectCountry

	return []interface{}{m}
}

func flattenTLSCertificateSlice(objs *[]restapi.TLSCertificate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTLSCertificate(&v))
	}
	return sl
}

func expandTLSCertificate(in interface{}) *restapi.TLSCertificate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TLSCertificate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["created_at"]; ok {
		obj.CreatedAt = *expandString(v)
	}
	if v, ok := m["description"]; ok {
		obj.Description = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["certificate_pem"]; ok {
		obj.CertificatePEM = *expandString(v)
	}
	if v, ok := m["subject_common_name"]; ok {
		obj.SubjectCommonName = *expandString(v)
	}
	if v, ok := m["subject_alternative_names"]; ok {
		obj.SubjectAlternativeNames = *expandTLSCertificateSANs(v)
	}
	if v, ok := m["issued_at"]; ok {
		obj.IssuedAt = expandString(v)
	}
	if v, ok := m["not_before"]; ok {
		obj.NotBefore = *expandString(v)
	}
	if v, ok := m["not_after"]; ok {
		obj.NotAfter = *expandString(v)
	}
	if v, ok := m["key_usages"]; ok {
		obj.KeyUsages = *expandStringSlice(v)
	}
	if v, ok := m["extended_key_usages"]; ok {
		obj.ExtendedKeyUsages = *expandStringSlice(v)
	}
	if v, ok := m["private_key_type"]; ok {
		obj.PrivateKeyType = *expandString(v)
	}
	if v, ok := m["issuer_common_name"]; ok {
		obj.IssuerCommonName = *expandString(v)
	}
	if v, ok := m["serial_number"]; ok {
		obj.SerialNumber = *expandString(v)
	}
	if v, ok := m["subject_organization"]; ok {
		obj.SubjectOrganization = *expandString(v)
	}
	if v, ok := m["subject_organizational_unit"]; ok {
		obj.SubjectOrganizationalUnit = *expandString(v)
	}
	if v, ok := m["subject_locality"]; ok {
		obj.SubjectLocality = *expandString(v)
	}
	if v, ok := m["subject_province"]; ok {
		obj.SubjectProvince = *expandString(v)
	}
	if v, ok := m["subject_country"]; ok {
		obj.SubjectCountry = *expandString(v)
	}
	return &obj
}

func expandTLSCertificateSlice(in interface{}) *[]restapi.TLSCertificate {
	var out []restapi.TLSCertificate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTLSCertificate(v))
	}
	return &out
}

func flattenTLSCertificateList(obj *restapi.TLSCertificateList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["tls_certificates"] = flattenTLSCertificateSlice(&obj.TLSCertificates)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenTLSCertificateListSlice(objs *[]restapi.TLSCertificateList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTLSCertificateList(&v))
	}
	return sl
}

func expandTLSCertificateList(in interface{}) *restapi.TLSCertificateList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TLSCertificateList
	if v, ok := m["tls_certificates"]; ok {
		obj.TLSCertificates = *expandTLSCertificateSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandTLSCertificateListSlice(in interface{}) *[]restapi.TLSCertificateList {
	var out []restapi.TLSCertificateList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTLSCertificateList(v))
	}
	return &out
}

func flattenTLSCertificateSANs(obj *restapi.TLSCertificateSANs) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["dns_names"] = obj.DNSNames
	m["ips"] = obj.IPs

	return []interface{}{m}
}

func flattenTLSCertificateSANsSlice(objs *[]restapi.TLSCertificateSANs) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTLSCertificateSANs(&v))
	}
	return sl
}

func expandTLSCertificateSANs(in interface{}) *restapi.TLSCertificateSANs {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TLSCertificateSANs
	if v, ok := m["dns_names"]; ok {
		obj.DNSNames = *expandStringSlice(v)
	}
	if v, ok := m["ips"]; ok {
		obj.IPs = *expandStringSlice(v)
	}
	return &obj
}

func expandTLSCertificateSANsSlice(in interface{}) *[]restapi.TLSCertificateSANs {
	var out []restapi.TLSCertificateSANs
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTLSCertificateSANs(v))
	}
	return &out
}

func flattenTunnelSession(obj *restapi.TunnelSession) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["agent_version"] = obj.AgentVersion
	m["credential"] = flattenRef(&obj.Credential)
	m["ngrok_id"] = obj.ID
	m["ip"] = obj.IP
	m["metadata"] = obj.Metadata
	m["os"] = obj.OS
	m["region"] = obj.Region
	m["started_at"] = obj.StartedAt
	m["transport"] = obj.Transport
	m["uri"] = obj.URI

	return []interface{}{m}
}

func flattenTunnelSessionSlice(objs *[]restapi.TunnelSession) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTunnelSession(&v))
	}
	return sl
}

func expandTunnelSession(in interface{}) *restapi.TunnelSession {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TunnelSession
	if v, ok := m["agent_version"]; ok {
		obj.AgentVersion = *expandString(v)
	}
	if v, ok := m["credential"]; ok {
		obj.Credential = *expandRef(v)
	}
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["ip"]; ok {
		obj.IP = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["os"]; ok {
		obj.OS = *expandString(v)
	}
	if v, ok := m["region"]; ok {
		obj.Region = *expandString(v)
	}
	if v, ok := m["started_at"]; ok {
		obj.StartedAt = *expandString(v)
	}
	if v, ok := m["transport"]; ok {
		obj.Transport = *expandString(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	return &obj
}

func expandTunnelSessionSlice(in interface{}) *[]restapi.TunnelSession {
	var out []restapi.TunnelSession
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTunnelSession(v))
	}
	return &out
}

func flattenTunnelSessionList(obj *restapi.TunnelSessionList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["tunnel_sessions"] = flattenTunnelSessionSlice(&obj.TunnelSessions)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenTunnelSessionListSlice(objs *[]restapi.TunnelSessionList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTunnelSessionList(&v))
	}
	return sl
}

func expandTunnelSessionList(in interface{}) *restapi.TunnelSessionList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TunnelSessionList
	if v, ok := m["tunnel_sessions"]; ok {
		obj.TunnelSessions = *expandTunnelSessionSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandTunnelSessionListSlice(in interface{}) *[]restapi.TunnelSessionList {
	var out []restapi.TunnelSessionList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTunnelSessionList(v))
	}
	return &out
}

func flattenTunnelSessionsUpdate(obj *restapi.TunnelSessionsUpdate) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["version"] = obj.Version

	return []interface{}{m}
}

func flattenTunnelSessionsUpdateSlice(objs *[]restapi.TunnelSessionsUpdate) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTunnelSessionsUpdate(&v))
	}
	return sl
}

func expandTunnelSessionsUpdate(in interface{}) *restapi.TunnelSessionsUpdate {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TunnelSessionsUpdate
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["version"]; ok {
		obj.Version = *expandString(v)
	}
	return &obj
}

func expandTunnelSessionsUpdateSlice(in interface{}) *[]restapi.TunnelSessionsUpdate {
	var out []restapi.TunnelSessionsUpdate
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTunnelSessionsUpdate(v))
	}
	return &out
}

func flattenTunnel(obj *restapi.Tunnel) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["ngrok_id"] = obj.ID
	m["public_url"] = obj.PublicURL
	m["started_at"] = obj.StartedAt
	m["metadata"] = obj.Metadata
	m["proto"] = obj.Proto
	m["region"] = obj.Region
	m["tunnel_session"] = flattenRef(&obj.TunnelSession)

	return []interface{}{m}
}

func flattenTunnelSlice(objs *[]restapi.Tunnel) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTunnel(&v))
	}
	return sl
}

func expandTunnel(in interface{}) *restapi.Tunnel {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.Tunnel
	if v, ok := m["ngrok_id"]; ok {
		obj.ID = *expandString(v)
	}
	if v, ok := m["public_url"]; ok {
		obj.PublicURL = *expandString(v)
	}
	if v, ok := m["started_at"]; ok {
		obj.StartedAt = *expandString(v)
	}
	if v, ok := m["metadata"]; ok {
		obj.Metadata = *expandString(v)
	}
	if v, ok := m["proto"]; ok {
		obj.Proto = *expandString(v)
	}
	if v, ok := m["region"]; ok {
		obj.Region = *expandString(v)
	}
	if v, ok := m["tunnel_session"]; ok {
		obj.TunnelSession = *expandRef(v)
	}
	return &obj
}

func expandTunnelSlice(in interface{}) *[]restapi.Tunnel {
	var out []restapi.Tunnel
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTunnel(v))
	}
	return &out
}

func flattenTunnelList(obj *restapi.TunnelList) interface{} {
	if obj == nil {
		return nil
	}

	m := make(map[string]interface{})
	m["tunnels"] = flattenTunnelSlice(&obj.Tunnels)
	m["uri"] = obj.URI
	m["next_page_uri"] = *obj.NextPageURI

	return []interface{}{m}
}

func flattenTunnelListSlice(objs *[]restapi.TunnelList) (sl []interface{}) {
	if objs == nil {
		return nil
	}

	for _, v := range *objs {
		sl = append(sl, flattenTunnelList(&v))
	}
	return sl
}

func expandTunnelList(in interface{}) *restapi.TunnelList {
	if in == nil {
		return nil
	}
	v := in.([]interface{})
	if len(v) == 0 {
		return nil
	}
	m := v[0].(map[string]interface{})

	var obj restapi.TunnelList
	if v, ok := m["tunnels"]; ok {
		obj.Tunnels = *expandTunnelSlice(v)
	}
	if v, ok := m["uri"]; ok {
		obj.URI = *expandString(v)
	}
	if v, ok := m["next_page_uri"]; ok {
		obj.NextPageURI = expandString(v)
	}
	return &obj
}

func expandTunnelListSlice(in interface{}) *[]restapi.TunnelList {
	var out []restapi.TunnelList
	for _, v := range in.([]interface{}) {
		out = append(out, *expandTunnelList(v))
	}
	return &out
}

func expandString(v interface{}) *string {
	x := v.(string)
	return &x
}

func expandInt32(v interface{}) *int32 {
	x := int32(v.(int))
	return &x
}

func expandInt64(v interface{}) *int64 {
	x := int64(v.(int))
	return &x
}

func expandUint32(v interface{}) *uint32 {
	x := uint32(v.(int))
	return &x
}

func expandUint64(v interface{}) *uint64 {
	x := uint64(v.(int))
	return &x
}

func expandBool(v interface{}) *bool {
	x := v.(bool)
	return &x
}

func expandFloat64(v interface{}) *float64 {
	x := v.(float64)
	return &x
}

func expandByteSlice(v interface{}) *[]byte {
	x := []byte(v.(string))
	return &x
}

func expandStringSlice(vs interface{}) *[]string {
	var out []string
	for _, v := range vs.([]interface{}) {
		out = append(out, v.(string))
	}
	return &out
}

func expandStringMap(vs interface{}) *map[string]string {
	out := make(map[string]string)
	for k, v := range vs.(map[string]interface{}) {
		out[k] = v.(string)
	}
	return &out
}
